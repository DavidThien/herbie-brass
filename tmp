'(#s(test "Random Jason Timeout Test 001" (x) (+ x (asin (cosh x))) #f #t TRUE binary64) #s(test "Random Jason Timeout Test 009" (x y) (fabs (fmod y (asin (- 2.821952756469356e+184 x)))) #f #t TRUE binary64) #s(test "Area of a triangle" (a b c) (sqrt (* (* (* (/ (+ (+ a b) c) 2) (- (/ (+ (+ a b) c) 2) a)) (- (/ (+ (+ a b) c) 2) b)) (- (/ (+ (+ a b) c) 2) c))) #f #t (and (< 0 a) (< 0 b) (< 0 c)) binary64) #s(test "Toniolo and Linder, Equation (13)" (n U t l Om U*) (sqrt (* (* (* 2 n) U) (- (- t (* 2 (/ (* l l) Om))) (* (* n (pow (/ l Om) 2)) (- U U*))))) #f #t TRUE binary64) #s(test "Random Jason Timeout Test 003" (a b) (sin (pow (sqrt (atan2 b b)) (- b a))) #f #t TRUE binary64) #s(test "Random Jason Timeout Test 015" (a b) (sin (pow (sqrt (atan2 b b)) (- b a))) #f #t TRUE binary64) #s(test "(/ (- x lo) (- hi lo))" (lo hi x) (/ (- x lo) (- hi lo)) #f #t (and (< lo -1e+308) (> hi 1e+308)) binary64) #s(test "Random Jason Timeout Test 002" (c) (fmod (sinh c) (- c (pow -2.9807307601812193e+165 2))) #f #t TRUE binary64) #s(test "Random Jason Timeout Test 004" (a c) (fmod (cosh c) (log1p a)) #f #t TRUE binary64) #s(test "Random Jason Timeout Test 012" (a) (acos (pow (fmod (cosh a) (* a a)) (log1p a))) #f #t TRUE binary64) #s(test "Random Jason Timeout Test 014" (c) (fmod (sinh c) (- c (pow -2.9807307601812193e+165 2))) #f #t TRUE binary64) #s(test "Random Jason Timeout Test 006" (a) (fabs (fmod (atan2 (expm1 (sin (expm1 a))) (atan a)) a)) #f #t TRUE binary64) #s(test "exp with complex power real part (p55)" (xre xim) (re (/.c (+.c (exp.c (complex xre xim)) (exp.c (neg.c (complex xre xim)))) (complex 2 0))) #f #t TRUE binary64) #s(test "exp with complex power imaginary part (p55)" (xre xim) (im (/.c (+.c (exp.c (complex xre xim)) (exp.c (neg.c (complex xre xim)))) (complex 2 0))) #f #t TRUE binary64) #s(test "Euler formula real part (p55)" (x y) (re (complex (* (/ (+ (exp x) (exp (- x))) 2) (cos y)) (* (/ (- (exp x) (exp (- x))) 2) (sin y)))) #f #t TRUE binary64) #s(test "Euler formula imaginary part (p55)" (x y) (im (complex (* (/ (+ (exp x) (exp (- x))) 2) (cos y)) (* (/ (- (exp x) (exp (- x))) 2) (sin y)))) #f #t TRUE binary64) #s(test "3.9.1 real part (p56)" () (re (+.c (+.c (+.c (+.c (+.c (+.c (*.c (*.c (*.c (*.c (*.c (complex -1 1) (complex -1 1)) (complex -1 1)) (complex -1 1)) (complex -1 1)) (complex -1 1)) (*.c (*.c (*.c (*.c (*.c (complex 6 0) (complex -1 1)) (complex -1 1)) (complex -1 1)) (complex -1 1)) (complex -1 1))) (*.c (*.c (*.c (*.c (complex 15 0) (complex -1 1)) (complex -1 1)) (complex -1 1)) (complex -1 1))) (*.c (*.c (*.c (complex 20 0) (complex -1 1)) (complex -1 1)) (complex -1 1))) (*.c (*.c (complex 15 0) (complex -1 1)) (complex -1 1))) (*.c (complex 6 0) (complex -1 1))) (complex 1 0))) #f #t TRUE binary64) #s(test "3.9.1 imaginary part (p56)" () (im (+.c (+.c (+.c (+.c (+.c (+.c (*.c (*.c (*.c (*.c (*.c (complex -1 1) (complex -1 1)) (complex -1 1)) (complex -1 1)) (complex -1 1)) (complex -1 1)) (*.c (*.c (*.c (*.c (*.c (complex 6 0) (complex -1 1)) (complex -1 1)) (complex -1 1)) (complex -1 1)) (complex -1 1))) (*.c (*.c (*.c (*.c (complex 15 0) (complex -1 1)) (complex -1 1)) (complex -1 1)) (complex -1 1))) (*.c (*.c (*.c (complex 20 0) (complex -1 1)) (complex -1 1)) (complex -1 1))) (*.c (*.c (complex 15 0) (complex -1 1)) (complex -1 1))) (*.c (complex 6 0) (complex -1 1))) (complex 1 0))) #f #t TRUE binary64) #s(test "3.9.2 real part (p56)" () (re (+.c (+.c (+.c (+.c (*.c (*.c (*.c (complex (/ (- 1) 2) (/ (sqrt 3) 2)) (complex (/ (- 1) 2) (/ (sqrt 3) 2))) (complex (/ (- 1) 2) (/ (sqrt 3) 2))) (complex (/ (- 1) 2) (/ (sqrt 3) 2))) (*.c (*.c (*.c (complex (- 2) 0) (complex (/ (- 1) 2) (/ (sqrt 3) 2))) (complex (/ (- 1) 2) (/ (sqrt 3) 2))) (complex (/ (- 1) 2) (/ (sqrt 3) 2)))) (*.c (*.c (complex 5 0) (complex (/ (- 1) 2) (/ (sqrt 3) 2))) (complex (/ (- 1) 2) (/ (sqrt 3) 2)))) (*.c (complex 4 0) (complex (/ (- 1) 2) (/ (sqrt 3) 2)))) (complex 7 0))) #f #t TRUE binary64) #s(test "3.9.2 imaginary part (p56)" () (im (+.c (+.c (+.c (+.c (*.c (*.c (*.c (complex (/ (- 1) 2) (/ (sqrt 3) 2)) (complex (/ (- 1) 2) (/ (sqrt 3) 2))) (complex (/ (- 1) 2) (/ (sqrt 3) 2))) (complex (/ (- 1) 2) (/ (sqrt 3) 2))) (*.c (*.c (*.c (complex (- 2) 0) (complex (/ (- 1) 2) (/ (sqrt 3) 2))) (complex (/ (- 1) 2) (/ (sqrt 3) 2))) (complex (/ (- 1) 2) (/ (sqrt 3) 2)))) (*.c (*.c (complex 5 0) (complex (/ (- 1) 2) (/ (sqrt 3) 2))) (complex (/ (- 1) 2) (/ (sqrt 3) 2)))) (*.c (complex 4 0) (complex (/ (- 1) 2) (/ (sqrt 3) 2)))) (complex 7 0))) #f #t TRUE binary64) #s(test "expax (section 3.5)" (a x) (- (exp (* a x)) 1) (if (< (fabs (* a x)) 1/10) (* (* a x) (+ 1 (+ (/ (* a x) 2) (/ (pow (* a x) 2) 6)))) (- (exp (* a x)) 1)) 14 TRUE binary64) #s(test "expq2 (section 3.11)" (x) (/ (exp x) (- (exp x) 1)) (/ 1 (- 1 (exp (- x)))) #t TRUE binary64) #s(test "quadp (p42, positive)" (a b c) (/ (+ (- b) (sqrt (- (* b b) (* 4 (* a c))))) (* 2 a)) (if (< b 0) (/ (+ (- b) (sqrt (- (* b b) (* 4 (* a c))))) (* 2 a)) (/ c (* a (/ (- (- b) (sqrt (- (* b b) (* 4 (* a c))))) (* 2 a))))) #t TRUE binary64) #s(test "quadm (p42, negative)" (a b c) (/ (- (- b) (sqrt (- (* b b) (* 4 (* a c))))) (* 2 a)) (if (< b 0) (/ c (* a (/ (+ (- b) (sqrt (- (* b b) (* 4 (* a c))))) (* 2 a)))) (/ (- (- b) (sqrt (- (* b b) (* 4 (* a c))))) (* 2 a))) #t TRUE binary64) #s(test "quad2m (problem 3.2.1, negative)" (a b_2 c) (/ (- (- b_2) (sqrt (- (* b_2 b_2) (* a c)))) a) #f #t TRUE binary64) #s(test "quad2p (problem 3.2.1, positive)" (a b_2 c) (/ (+ (- b_2) (sqrt (- (* b_2 b_2) (* a c)))) a) #f #t TRUE binary64) #s(test "2sqrt (example 3.1)" (x) (- (sqrt (+ x 1)) (sqrt x)) (/ 1 (+ (sqrt (+ x 1)) (sqrt x))) #t TRUE binary64) #s(test "2sin (example 3.3)" (x eps) (- (sin (+ x eps)) (sin x)) (* 2 (* (cos (+ x (/ eps 2))) (sin (/ eps 2)))) #t TRUE binary64) #s(test "tanhf (example 3.4)" (x) (/ (- 1 (cos x)) (sin x)) (tan (/ x 2)) 2 TRUE binary64) #s(test "2atan (example 3.5)" (N) (- (atan (+ N 1)) (atan N)) (atan (/ 1 (+ 1 (* N (+ N 1))))) #t TRUE binary64) #s(test "2isqrt (example 3.6)" (x) (- (/ 1 (sqrt x)) (/ 1 (sqrt (+ x 1)))) (/ 1 (+ (* (+ x 1) (sqrt x)) (* x (sqrt (+ x 1))))) #t TRUE binary64) #s(test "2frac (problem 3.3.1)" (x) (- (/ 1 (+ x 1)) (/ 1 x)) #f #t TRUE binary64) #s(test "2tan (problem 3.3.2)" (x eps) (- (tan (+ x eps)) (tan x)) (/ (sin eps) (* (cos x) (cos (+ x eps)))) #t TRUE binary64) #s(test "3frac (problem 3.3.3)" (x) (+ (- (/ 1 (+ x 1)) (/ 2 x)) (/ 1 (- x 1))) (/ 2 (* x (- (* x x) 1))) #t TRUE binary64) #s(test "2cbrt (problem 3.3.4)" (x) (- (cbrt (+ x 1)) (cbrt x)) #f #t TRUE binary64) #s(test "2cos (problem 3.3.5)" (x eps) (- (cos (+ x eps)) (cos x)) #f #t TRUE binary64) #s(test "2log (problem 3.3.6)" (N) (- (log (+ N 1)) (log N)) #f #t TRUE binary64) #s(test "exp2 (problem 3.3.7)" (x) (+ (- (exp x) 2) (exp (- x))) (* 4 (pow (sinh (/ x 2)) 2)) #t TRUE binary64) #s(test "expm1 (example 3.7)" (x) (- (exp x) 1) (* x (+ (+ 1 (/ x 2)) (/ (* x x) 6))) #t (< -0.00017 x) binary64) #s(test "logs (example 3.8)" (n) (- (- (* (+ n 1) (log (+ n 1))) (* n (log n))) 1) (- (log (+ n 1)) (- (/ 1 (* 2 n)) (- (/ 1 (* 3 (* n n))) (/ 4 (pow n 3))))) #t (> n 6.8e+15) binary64) #s(test "invcot (example 3.9)" (x) (- (/ 1 x) (/ 1 (tan x))) (if (< (fabs x) 0.026) (* (/ x 3) (+ 1 (/ (* x x) 15))) (- (/ 1 x) (/ 1 (tan x)))) #t (and (< -0.026 x) (< x 0.026)) binary64) #s(test "qlog (example 3.10)" (x) (/ (log (- 1 x)) (log (+ 1 x))) (- (+ (+ (+ 1 x) (/ (* x x) 2)) (* 5/12 (pow x 3)))) #t (and (< -1 x) (< x 1)) binary64) #s(test "cos2 (problem 3.4.1)" (x) (/ (- 1 (cos x)) (* x x)) #f #t TRUE binary64) #s(test "expq3 (problem 3.4.2)" (a b eps) (/ (* eps (- (exp (* (+ a b) eps)) 1)) (* (- (exp (* a eps)) 1) (- (exp (* b eps)) 1))) (/ (+ a b) (* a b)) #t (and (< -1 eps) (< eps 1)) binary64) #s(test "logq (problem 3.4.3)" (eps) (log (/ (- 1 eps) (+ 1 eps))) (* -2 (+ (+ eps (/ (pow eps 3) 3)) (/ (pow eps 5) 5))) #t TRUE binary64) #s(test "sqrtexp (problem 3.4.4)" (x) (sqrt (/ (- (exp (* 2 x)) 1) (- (exp x) 1))) #f #t TRUE binary64) #s(test "sintan (problem 3.4.5)" (x) (/ (- x (sin x)) (- x (tan x))) #f #t TRUE binary64) #s(test "2nthrt (problem 3.4.6)" (x n) (- (pow (+ x 1) (/ 1 n)) (pow x (/ 1 n))) #f #t TRUE binary64) #s(test "Optimisation.CirclePacking:place from circle-packing-0.1.0.4, A" (x y) (sqrt (+ x y)) #f #t TRUE binary64) #s(test "Optimisation.CirclePacking:place from circle-packing-0.1.0.4, B" (x y z t) (/ (- (+ x y) z) (* t 2.0)) #f #t TRUE binary64) #s(test "Optimisation.CirclePacking:place from circle-packing-0.1.0.4, C" (x y) (sqrt (fabs (- x y))) #f #t TRUE binary64) #s(test "Optimisation.CirclePacking:place from circle-packing-0.1.0.4, D" (x y z t) (+ x (/ (* y (- z x)) t)) (- x (+ (* x (/ y t)) (* (- z) (/ y t)))) #t TRUE binary64) #s(test "Optimisation.CirclePacking:place from circle-packing-0.1.0.4, E" (x y z t a) (+ x (/ (* y (- z t)) a)) (if (< y -1.0761266216389975e-10) (+ x (/ 1 (/ (/ a (- z t)) y))) (if (< y 2.894426862792089e-49) (+ x (/ (* y (- z t)) a)) (+ x (/ y (/ a (- z t)))))) #t TRUE binary64) #s(test "Optimisation.CirclePacking:place from circle-packing-0.1.0.4, F" (x y z t a) (- x (/ (* y (- z t)) a)) (if (< y -1.0761266216389975e-10) (- x (/ 1 (/ (/ a (- z t)) y))) (if (< y 2.894426862792089e-49) (- x (/ (* y (- z t)) a)) (- x (/ y (/ a (- z t)))))) #t TRUE binary64) #s(test "Optimisation.CirclePacking:place from circle-packing-0.1.0.4, G" (x y z) (* (+ x y) (+ z 1.0)) #f #t TRUE binary64) #s(test "Optimisation.CirclePacking:place from circle-packing-0.1.0.4, H" (x y z) (* (+ x y) (- 1.0 z)) #f #t TRUE binary64) #s(test "Optimisation.CirclePacking:place from circle-packing-0.1.0.4, I" (x y z) (+ (+ x y) z) #f #t TRUE binary64) #s(test "Data.Colour.Matrix:determinant from colour-2.3.3, A" (x y z t a b c i j) (+ (- (* x (- (* y z) (* t a))) (* b (- (* c z) (* t i)))) (* j (- (* c a) (* y i)))) (if (< x -1.469694296777705e-64) (+ (- (* x (- (* y z) (* t a))) (/ (* b (- (pow (* c z) 2) (pow (* t i) 2))) (+ (* c z) (* t i)))) (* j (- (* c a) (* y i)))) (if (< x 3.2113527362226803e-147) (- (* (- (* b i) (* x a)) t) (- (* z (* c b)) (* j (- (* c a) (* y i))))) (+ (- (* x (- (* y z) (* t a))) (/ (* b (- (pow (* c z) 2) (pow (* t i) 2))) (+ (* c z) (* t i)))) (* j (- (* c a) (* y i)))))) #t TRUE binary64) #s(test "Data.Colour.Matrix:inverse from colour-2.3.3, B" (x y z t a) (/ (- (* x y) (* z t)) a) (if (< z -2.468684968699548e+170) (- (* (/ y a) x) (* (/ t a) z)) (if (< z 6.309831121978371e-71) (/ (- (* x y) (* z t)) a) (- (* (/ y a) x) (* (/ t a) z)))) #t TRUE binary64) #s(test "Data.Colour.CIE.Chromaticity:chromaCoords from colour-2.3.3" (x y) (- (- 1.0 x) y) #f #t TRUE binary64) #s(test "Data.Colour.RGB:hslsv from colour-2.3.3, A" (x y) (/ (+ x y) 2.0) #f #t TRUE binary64) #s(test "Data.Colour.RGB:hslsv from colour-2.3.3, B" (x y z t a) (+ (/ (* 60.0 (- x y)) (- z t)) (* a 120.0)) (+ (/ 60.0 (/ (- z t) (- x y))) (* a 120.0)) #t TRUE binary64) #s(test "Data.Colour.RGB:hslsv from colour-2.3.3, C" (x y) (/ (- x y) (- 2.0 (+ x y))) (- (/ x (- 2.0 (+ x y))) (/ y (- 2.0 (+ x y)))) #t TRUE binary64) #s(test "Data.Colour.RGB:hslsv from colour-2.3.3, D" (x y) (/ (- x y) (+ x y)) (- (/ x (+ x y)) (/ y (+ x y))) #t TRUE binary64) #s(test "Data.Colour.RGB:hslsv from colour-2.3.3, E" (x y) (/ (- x y) x) (- 1 (/ y x)) #t TRUE binary64) #s(test "Data.Colour.RGBSpace.HSL:hsl from colour-2.3.3, A" (x y) (- (+ x y) (* x y)) #f #t TRUE binary64) #s(test "Data.Colour.RGBSpace.HSL:hsl from colour-2.3.3, B" (x y) (* x (+ y 1.0)) (+ x (* x y)) #t TRUE binary64) #s(test "Data.Colour.RGBSpace.HSL:hsl from colour-2.3.3, C" (x y) (- (* x 2.0) y) #f #t TRUE binary64) #s(test "Data.Colour.RGBSpace.HSL:hsl from colour-2.3.3, D" (x y z) (+ x (* (* (- y x) 6.0) (- (/ 2.0 3.0) z))) #f #t TRUE binary64) #s(test "Data.Colour.RGBSpace.HSL:hsl from colour-2.3.3, E" (x y z) (+ x (* (* (- y x) 6.0) z)) (- x (* (* 6.0 z) (- x y))) #t TRUE binary64) #s(test "Data.Colour.RGBSpace.HSL:hsl from colour-2.3.3, F" (x) (+ x (/ 1.0 3.0)) #f #t TRUE binary64) #s(test "Data.Colour.RGBSpace.HSL:hsl from colour-2.3.3, G" (x) (- x (/ 1.0 3.0)) #f #t TRUE binary64) #s(test "Data.Colour.RGBSpace.HSV:hsv from colour-2.3.3, H" (x y) (* x (- 1.0 y)) #f #t TRUE binary64) #s(test "Data.Colour.RGBSpace.HSV:hsv from colour-2.3.3, I" (x y z) (* x (- 1.0 (* y z))) #f #t TRUE binary64) #s(test "Data.Colour.RGBSpace.HSV:hsv from colour-2.3.3, J" (x y z) (* x (- 1.0 (* (- 1.0 y) z))) (if (< (* x (- 1.0 (* (- 1.0 y) z))) -1.618195973607049e+50) (+ x (* (- 1.0 y) (* (- z) x))) (if (< (* x (- 1.0 (* (- 1.0 y) z))) 3.892237649663903e+134) (- (* (* x y) z) (- (* x z) x)) (+ x (* (- 1.0 y) (* (- z) x))))) #t TRUE binary64) #s(test "Data.Colour.SRGB:invTransferFunction from colour-2.3.3" (x y) (/ (+ x y) (+ y 1.0)) #f #t TRUE binary64) #s(test "Data.Colour.SRGB:transferFunction from colour-2.3.3" (x y) (- (* (+ x 1.0) y) x) #f #t TRUE binary64) #s(test "Data.Colour.CIE:lightness from colour-2.3.3" (x) (- (* x 116.0) 16.0) #f #t TRUE binary64) #s(test "Data.Colour.CIE:cieLABView from colour-2.3.3, A" (x) (+ (* (/ 841.0 108.0) x) (/ 4.0 29.0)) #f #t TRUE binary64) #s(test "Data.Colour.CIE:cieLABView from colour-2.3.3, B" (x y) (* 500.0 (- x y)) #f #t TRUE binary64) #s(test "Data.Colour.CIE:cieLABView from colour-2.3.3, C" (x y) (* 200.0 (- x y)) #f #t TRUE binary64) #s(test "Data.Colour.CIE:cieLAB from colour-2.3.3, A" (x y) (* (* (- x (/ 16.0 116.0)) 3.0) y) (* y (- (* x 3.0) 0.41379310344827586)) #t TRUE binary64) #s(test "Data.Colour.CIE:cieLAB from colour-2.3.3, B" (x) (/ (+ x 16.0) 116.0) #f #t TRUE binary64) #s(test "Data.Colour.CIE:cieLAB from colour-2.3.3, C" (x y) (+ x (/ y 500.0)) #f #t TRUE binary64) #s(test "Data.Colour.CIE:cieLAB from colour-2.3.3, D" (x y) (- x (/ y 200.0)) #f #t TRUE binary64) #s(test "Diagrams.Solve.Tridiagonal:solveTriDiagonal from diagrams-solve-0.1, A" (x y z t a) (/ (- x (* y z)) (- t (* a z))) (if (< z -32113435955957344.0) (- (/ x (- t (* a z))) (/ y (- (/ t z) a))) (if (< z 3.5139522372978296e-86) (* (- x (* y z)) (/ 1 (- t (* a z)))) (- (/ x (- t (* a z))) (/ y (- (/ t z) a))))) #t TRUE binary64) #s(test "Diagrams.Solve.Tridiagonal:solveTriDiagonal from diagrams-solve-0.1, B" (x y z t) (/ x (- y (* z t))) (if (< x -1.618195973607049e+50) (/ 1 (- (/ y x) (* (/ z x) t))) (if (< x 2.1378306434876444e+131) (/ x (- y (* z t))) (/ 1 (- (/ y x) (* (/ z x) t))))) #t TRUE binary64) #s(test "Diagrams.Solve.Tridiagonal:solveTriDiagonal from diagrams-solve-0.1, C" (x y z) (- x (* y z)) (/ (+ x (* y z)) (/ (+ x (* y z)) (- x (* y z)))) #t TRUE binary64) #s(test "Diagrams.Solve.Tridiagonal:solveCyclicTriDiagonal from diagrams-solve-0.1, A" (x y z) (/ (* x y) z) (if (< z -4.262230790519429e-138) (/ (* x y) z) (if (< z 1.7042130660650472e-164) (/ x (/ z y)) (* (/ x z) y))) #t TRUE binary64) #s(test "Diagrams.Solve.Tridiagonal:solveCyclicTriDiagonal from diagrams-solve-0.1, B" (x y z t a b) (/ (+ x (/ (* y z) t)) (+ (+ a 1.0) (/ (* y b) t))) (if (< t -1.3659085366310088e-271) (* 1 (* (+ x (* (/ y t) z)) (/ 1 (+ (+ a 1.0) (* (/ y t) b))))) (if (< t 3.036967103737246e-130) (/ z b) (* 1 (* (+ x (* (/ y t) z)) (/ 1 (+ (+ a 1.0) (* (/ y t) b))))))) #t TRUE binary64) #s(test "Diagrams.Solve.Polynomial:quadForm from diagrams-solve-0.1, A" (x y z) (- x (* (* y 4.0) z)) #f #t TRUE binary64) #s(test "Diagrams.Solve.Polynomial:quadForm from diagrams-solve-0.1, B" (x y z) (* (/ 1.0 2.0) (+ x (* y (sqrt z)))) #f #t TRUE binary64) #s(test "Diagrams.Solve.Polynomial:quadForm from diagrams-solve-0.1, C" (x y) (/ x (* y 2.0)) #f #t TRUE binary64) #s(test "Diagrams.Solve.Polynomial:cubForm  from diagrams-solve-0.1, A" (x y z t a b) (+ (- (* x 2.0) (* (* (* y 9.0) z) t)) (* (* a 27.0) b)) (if (< y 7.590524218811189e-161) (+ (- (* x 2.0) (* (* (* y 9.0) z) t)) (* a (* 27.0 b))) (+ (- (* x 2.0) (* 9.0 (* y (* t z)))) (* (* a 27.0) b))) #t TRUE binary64) #s(test "Diagrams.Solve.Polynomial:cubForm  from diagrams-solve-0.1, B" (x y z) (- (* (* x 3.0) y) z) (- (* x (* 3.0 y)) z) #t TRUE binary64) #s(test "Diagrams.Solve.Polynomial:cubForm  from diagrams-solve-0.1, C" (x y) (/ x (* y 3.0)) (/ (/ x y) 3.0) #t TRUE binary64) #s(test "Diagrams.Solve.Polynomial:cubForm  from diagrams-solve-0.1, D" (x y z t) (* (/ 1.0 3.0) (acos (* (/ (* 3.0 (/ x (* y 27.0))) (* z 2.0)) (sqrt t)))) (/ (acos (* (/ (/ x 27.0) (* y z)) (/ (sqrt t) (/ 2.0 3.0)))) 3.0) #t TRUE binary64) #s(test "Diagrams.Solve.Polynomial:cubForm  from diagrams-solve-0.1, E" (x y z t a b c i j k) (- (- (+ (- (* (* (* (* x 18.0) y) z) t) (* (* a 4.0) t)) (* b c)) (* (* x 4.0) i)) (* (* j 27.0) k)) (if (< t -1.6210815397541398e-69) (- (- (* (* 18.0 t) (* (* x y) z)) (* (+ (* a t) (* i x)) 4.0)) (- (* (* k j) 27.0) (* c b))) (if (< t 165.68027943805222) (+ (- (* (* 18.0 y) (* x (* z t))) (* (+ (* a t) (* i x)) 4.0)) (- (* c b) (* 27.0 (* k j)))) (- (- (* (* 18.0 t) (* (* x y) z)) (* (+ (* a t) (* i x)) 4.0)) (- (* (* k j) 27.0) (* c b))))) #t TRUE binary64) #s(test "Diagrams.Solve.Polynomial:cubForm  from diagrams-solve-0.1, F" (x y) (* (* x 27.0) y) #f #t TRUE binary64) #s(test "Diagrams.Solve.Polynomial:cubForm  from diagrams-solve-0.1, G" (x y) (* (/ 1.0 2.0) (+ x y)) (/ (+ x y) 2.0) #t TRUE binary64) #s(test "Diagrams.Solve.Polynomial:cubForm  from diagrams-solve-0.1, H" (x y z t) (+ (- x (/ y (* z 3.0))) (/ t (* (* z 3.0) y))) (+ (- x (/ y (* z 3.0))) (/ (/ t (* z 3.0)) y)) #t TRUE binary64) #s(test "Diagrams.Solve.Polynomial:cubForm  from diagrams-solve-0.1, I" (x y z t a) (/ (- (* x y) (* (* z 9.0) t)) (* a 2.0)) (if (< a -2.090464557976709e+86) (- (* 0.5 (/ (* y x) a)) (* 4.5 (/ t (/ a z)))) (if (< a 2.144030707833976e+99) (/ (- (* x y) (* z (* 9.0 t))) (* a 2.0)) (- (* (/ y a) (* x 0.5)) (* (/ t a) (* z 4.5))))) #t TRUE binary64) #s(test "Diagrams.Solve.Polynomial:cubForm  from diagrams-solve-0.1, J" (x y z t a b c) (/ (+ (- (* (* x 9.0) y) (* (* (* z 4.0) t) a)) b) (* z c)) (if (< (/ (+ (- (* (* x 9.0) y) (* (* (* z 4.0) t) a)) b) (* z c)) -1.100156740804105e-171) (/ (+ (- (* (* x 9.0) y) (* (* z 4.0) (* t a))) b) (* z c)) (if (< (/ (+ (- (* (* x 9.0) y) (* (* (* z 4.0) t) a)) b) (* z c)) -0.0) (/ (/ (+ (- (* (* x 9.0) y) (* (* (* z 4.0) t) a)) b) z) c) (if (< (/ (+ (- (* (* x 9.0) y) (* (* (* z 4.0) t) a)) b) (* z c)) 1.1708877911747488e-53) (/ (+ (- (* (* x 9.0) y) (* (* z 4.0) (* t a))) b) (* z c)) (if (< (/ (+ (- (* (* x 9.0) y) (* (* (* z 4.0) t) a)) b) (* z c)) 2.876823679546137e+130) (- (+ (* (* 9.0 (/ y c)) (/ x z)) (/ b (* c z))) (* 4.0 (/ (* a t) c))) (if (< (/ (+ (- (* (* x 9.0) y) (* (* (* z 4.0) t) a)) b) (* z c)) 1.3838515042456319e+158) (/ (+ (- (* (* x 9.0) y) (* (* z 4.0) (* t a))) b) (* z c)) (- (+ (* 9.0 (* (/ y (* c z)) x)) (/ b (* c z))) (* 4.0 (/ (* a t) c)))))))) #t TRUE binary64) #s(test "Diagrams.Solve.Polynomial:cubForm  from diagrams-solve-0.1, K" (x y z t a b) (- (* (* 2.0 (sqrt x)) (cos (- y (/ (* z t) 3.0)))) (/ a (* b 3.0))) (if (< z -1.3793337487235141e+129) (- (* (* 2.0 (sqrt x)) (cos (- (/ 1 y) (/ (/ 0.3333333333333333 z) t)))) (/ (/ a 3.0) b)) (if (< z 3.516290613555987e+106) (- (* (* (sqrt x) 2.0) (cos (- y (* (/ t 3.0) z)))) (/ (/ a 3.0) b)) (- (* (cos (- y (/ (/ 0.3333333333333333 z) t))) (* 2.0 (sqrt x))) (/ (/ a b) 3.0)))) #t TRUE binary64) #s(test "Diagrams.Solve.Polynomial:quartForm  from diagrams-solve-0.1, A" (x y) (- x (* (/ 3.0 8.0) y)) #f #t TRUE binary64) #s(test "Diagrams.Solve.Polynomial:quartForm  from diagrams-solve-0.1, B" (x y z t) (+ (- (* (/ 1.0 8.0) x) (/ (* y z) 2.0)) t) (- (+ (/ x 8.0) t) (* (/ z 2.0) y)) #t TRUE binary64) #s(test "Diagrams.Solve.Polynomial:quartForm  from diagrams-solve-0.1, C" (x y z t a b c) (+ (- (+ (* x y) (/ (* z t) 16.0)) (/ (* a b) 4.0)) c) #f #t TRUE binary64) #s(test "Diagrams.Solve.Polynomial:quartForm  from diagrams-solve-0.1, D" (x y z) (- (/ (* x y) 2.0) (/ z 8.0)) #f #t TRUE binary64) #s(test "Diagrams.Solve.Polynomial:quartForm  from diagrams-solve-0.1, E" (x y) (- x (/ y 4.0)) #f #t TRUE binary64) #s(test "Text.Parsec.Token:makeTokenParser from parsec-3.1.9, A" (x y) (/ (+ x y) 10.0) #f #t TRUE binary64) #s(test "Text.Parsec.Token:makeTokenParser from parsec-3.1.9, B" (x y z) (* (+ x y) z) #f #t TRUE binary64) #s(test "Numeric.Interval.Internal:bisect from intervals-0.7.1, A" (x y) (+ x (/ (- y x) 2.0)) (* 0.5 (+ x y)) #t TRUE binary64) #s(test "Numeric.Interval.Internal:scale from intervals-0.7.1, B" (x y) (/ (* x y) 2.0) #f #t TRUE binary64) #s(test "Linear.V2:$cdot from linear-1.19.1.3, A" (x y z t) (+ (* x y) (* z t)) #f #t TRUE binary64) #s(test "Linear.V3:cross from linear-1.19.1.3" (x y z t) (- (* x y) (* z t)) #f #t TRUE binary64) #s(test "Linear.V3:$cdot from linear-1.19.1.3, B" (x y z t a b) (+ (+ (* x y) (* z t)) (* a b)) #f #t TRUE binary64) #s(test "Linear.V4:$cdot from linear-1.19.1.3, C" (x y z t a b c i) (+ (+ (+ (* x y) (* z t)) (* a b)) (* c i)) #f #t TRUE binary64) #s(test "Main:bigenough2 from A" (x y z) (+ x (* y (+ z x))) #f #t TRUE binary64) #s(test "Main:bigenough1 from B" (x) (+ x (* x x)) #f #t TRUE binary64) #s(test "Main:bigenough3 from C" (x) (- (sqrt (+ x 1.0)) (sqrt x)) (/ 1.0 (+ (sqrt (+ x 1.0)) (sqrt x))) #t TRUE binary64) #s(test "Linear.Quaternion:$c/ from linear-1.19.1.3, A" (x y z) (+ (+ (+ (* x y) (* z z)) (* z z)) (* z z)) (+ (* (* 3 z) z) (* y x)) #t TRUE binary64) #s(test "Linear.Quaternion:$c/ from linear-1.19.1.3, B" (x y z) (+ (- (- (* x y) (* y z)) (* y y)) (* y y)) (* (- x z) y) #t TRUE binary64) #s(test "Linear.Quaternion:$c/ from linear-1.19.1.3, C" (x y z) (- (- (+ (* x y) (* y y)) (* y z)) (* y y)) (* (- x z) y) #t TRUE binary64) #s(test "Linear.Quaternion:$c/ from linear-1.19.1.3, D" (x y z) (- (+ (- (* x y) (* y y)) (* y y)) (* y z)) (* (- x z) y) #t TRUE binary64) #s(test "Linear.Quaternion:$c/ from linear-1.19.1.3, E" (x y) (+ (+ (+ (* x x) (* y y)) (* y y)) (* y y)) (+ (* x x) (* y (+ y (+ y y)))) #t TRUE binary64) #s(test "Graphics.Rasterific.Linear:$cquadrance from Rasterific-0.6.1" (x y) (+ (* x x) (* y y)) #f #t TRUE binary64) #s(test "Linear.Quaternion:$ctanh from linear-1.19.1.3" (x y z) (/ (* x (/ (sin y) y)) z) (if (< z -4.2173720203427147e-29) (/ (* x (/ 1 (/ y (sin y)))) z) (if (< z 4.446702369113811e+64) (/ x (* z (/ y (sin y)))) (/ (* x (/ 1 (/ y (sin y)))) z))) #t TRUE binary64) #s(test "Linear.Quaternion:$ccosh from linear-1.19.1.3" (x y) (/ (* (sin x) (sinh y)) x) (* (sin x) (/ (sinh y) x)) #t TRUE binary64) #s(test "Linear.Quaternion:$csinh from linear-1.19.1.3" (x y) (* (cosh x) (/ (sin y) y)) (/ (* (cosh x) (sin y)) y) #t TRUE binary64) #s(test "Linear.Quaternion:$ctan from linear-1.19.1.3" (x y z) (/ (* (cosh x) (/ y x)) z) (if (< y -4.618902267687042e-52) (* (/ (/ y z) x) (cosh x)) (if (< y 1.038530535935153e-39) (/ (/ (* (cosh x) y) x) z) (* (/ (/ y z) x) (cosh x)))) #t TRUE binary64) #s(test "Linear.Quaternion:$ccos from linear-1.19.1.3" (x y) (* (sin x) (/ (sinh y) y)) #f #t TRUE binary64) #s(test "Linear.Quaternion:$csin from linear-1.19.1.3" (x y) (* (cos x) (/ (sinh y) y)) #f #t TRUE binary64) #s(test "Linear.Quaternion:$clog from linear-1.19.1.3" (x y) (sqrt (+ (* x x) y)) (if (< x -1.5097698010472593e+153) (- (+ (* 1/2 (/ y x)) x)) (if (< x 5.582399551122541e+57) (sqrt (+ (* x x) y)) (+ (* 1/2 (/ y x)) x))) #t TRUE binary64) #s(test "Linear.Quaternion:$cexp from linear-1.19.1.3" (x y) (* x (/ (sin y) y)) #f #t TRUE binary64) #s(test "Linear.Matrix:det44 from linear-1.19.1.3" (x y z t a b c i j k y0 y1 y2 y3 y4 y5) (+ (- (+ (+ (- (* (- (* x y) (* z t)) (- (* a b) (* c i))) (* (- (* x j) (* z k)) (- (* y0 b) (* y1 i)))) (* (- (* x y2) (* z y3)) (- (* y0 c) (* y1 a)))) (* (- (* t j) (* y k)) (- (* y4 b) (* y5 i)))) (* (- (* t y2) (* y y3)) (- (* y4 c) (* y5 a)))) (* (- (* k y2) (* j y3)) (- (* y4 y1) (* y5 y0)))) (if (< y4 -7.206256231996481e+60) (- (- (* (- (* b a) (* i c)) (- (* y x) (* t z))) (- (* (- (* j x) (* k z)) (- (* y0 b) (* i y1))) (* (- (* j t) (* k y)) (- (* y4 b) (* y5 i))))) (- (/ (- (* y2 t) (* y3 y)) (/ 1 (- (* y4 c) (* y5 a)))) (* (- (* y2 k) (* y3 j)) (- (* y4 y1) (* y5 y0))))) (if (< y4 -3.364603505246317e-66) (+ (- (- (- (* (* t c) (* i z)) (* (* a t) (* b z))) (* (* y c) (* i x))) (* (- (* b y0) (* i y1)) (- (* j x) (* k z)))) (- (* (- (* y0 c) (* a y1)) (- (* x y2) (* z y3))) (- (* (- (* t y2) (* y y3)) (- (* y4 c) (* a y5))) (* (- (* y1 y4) (* y5 y0)) (- (* k y2) (* j y3)))))) (if (< y4 -1.2000065055686116e-105) (+ (+ (- (* (- (* j t) (* k y)) (- (* y4 b) (* y5 i))) (* (* y3 y) (- (* y5 a) (* y4 c)))) (+ (* (* y5 a) (* t y2)) (* (- (* k y2) (* j y3)) (- (* y4 y1) (* y5 y0))))) (- (* (- (* x y2) (* z y3)) (- (* c y0) (* a y1))) (- (* (- (* b y0) (* i y1)) (- (* j x) (* k z))) (* (- (* y x) (* z t)) (- (* b a) (* i c)))))) (if (< y4 6.718963124057495e-279) (+ (- (- (- (* (* k y) (* y5 i)) (* (* y b) (* y4 k))) (* (* y5 t) (* i j))) (- (* (- (* y2 t) (* y3 y)) (- (* y4 c) (* y5 a))) (* (- (* y2 k) (* y3 j)) (- (* y4 y1) (* y5 y0))))) (- (* (- (* b a) (* i c)) (- (* y x) (* t z))) (- (* (- (* j x) (* k z)) (- (* y0 b) (* i y1))) (* (- (* y2 x) (* y3 z)) (- (* c y0) (* y1 a)))))) (if (< y4 4.77962681403792e-222) (+ (+ (- (* (- (* j t) (* k y)) (- (* y4 b) (* y5 i))) (* (* y3 y) (- (* y5 a) (* y4 c)))) (+ (* (* y5 a) (* t y2)) (* (- (* k y2) (* j y3)) (- (* y4 y1) (* y5 y0))))) (- (* (- (* x y2) (* z y3)) (- (* c y0) (* a y1))) (- (* (- (* b y0) (* i y1)) (- (* j x) (* k z))) (* (- (* y x) (* z t)) (- (* b a) (* i c)))))) (if (< y4 2.2852241541266835e-175) (+ (- (- (- (* (* k y) (* y5 i)) (* (* y b) (* y4 k))) (* (* y5 t) (* i j))) (- (* (- (* y2 t) (* y3 y)) (- (* y4 c) (* y5 a))) (* (- (* y2 k) (* y3 j)) (- (* y4 y1) (* y5 y0))))) (- (* (- (* b a) (* i c)) (- (* y x) (* t z))) (- (* (- (* j x) (* k z)) (- (* y0 b) (* i y1))) (* (- (* y2 x) (* y3 z)) (- (* c y0) (* y1 a)))))) (+ (- (+ (+ (- (* (- (* x y) (* z t)) (- (* a b) (* c i))) (- (* k (* i (* z y1))) (+ (* j (* i (* x y1))) (* y0 (* k (* z b)))))) (- (* z (* y3 (* a y1))) (+ (* y2 (* x (* a y1))) (* y0 (* z (* c y3)))))) (* (- (* t j) (* y k)) (- (* y4 b) (* y5 i)))) (* (- (* t y2) (* y y3)) (- (* y4 c) (* y5 a)))) (* (- (* k y2) (* j y3)) (- (* y4 y1) (* y5 y0)))))))))) #t TRUE binary64) #s(test "Linear.Matrix:det33 from linear-1.19.1.3" (x y z t a b c i j) (+ (- (* x (- (* y z) (* t a))) (* b (- (* c z) (* i a)))) (* j (- (* c t) (* i y)))) (if (< t -8.120978919195912e-33) (- (* x (- (* z y) (* a t))) (- (* b (- (* z c) (* a i))) (* (- (* c t) (* y i)) j))) (if (< t -4.712553818218485e-169) (+ (- (* x (- (* y z) (* t a))) (* b (- (* c z) (* i a)))) (/ (* j (- (pow (* c t) 2) (pow (* i y) 2))) (+ (* c t) (* i y)))) (if (< t -7.633533346031584e-308) (- (* x (- (* z y) (* a t))) (- (* b (- (* z c) (* a i))) (* (- (* c t) (* y i)) j))) (if (< t 1.0535888557455487e-139) (+ (- (* x (- (* y z) (* t a))) (* b (- (* c z) (* i a)))) (/ (* j (- (pow (* c t) 2) (pow (* i y) 2))) (+ (* c t) (* i y)))) (- (* x (- (* z y) (* a t))) (- (* b (- (* z c) (* a i))) (* (- (* c t) (* y i)) j))))))) #t TRUE binary64) #s(test "Linear.Matrix:fromQuaternion from linear-1.19.1.3, A" (x y) (* 2.0 (- (* x x) (* x y))) (* (* x 2.0) (- x y)) #t TRUE binary64) #s(test "Linear.Matrix:fromQuaternion from linear-1.19.1.3, B" (x y) (* 2.0 (+ (* x x) (* x y))) (* (* x 2.0) (+ x y)) #t TRUE binary64) #s(test "Linear.Projection:inverseInfinitePerspective from linear-1.19.1.3" (x y z t) (* (- (* x y) (* z y)) t) (if (< t -9.231879582886777e-80) (* (* y t) (- x z)) (if (< t 2.543067051564877e+83) (* y (* t (- x z))) (* (* y (- x z)) t))) #t TRUE binary64) #s(test "Linear.Projection:infinitePerspective from linear-1.19.1.3, A" (x y z t) (/ (* x 2.0) (- (* y z) (* t z))) (if (< (/ (* x 2.0) (- (* y z) (* t z))) -2.559141628295061e-13) (* (/ x (* (- y t) z)) 2.0) (if (< (/ (* x 2.0) (- (* y z) (* t z))) 1.045027827330126e-269) (/ (* (/ x z) 2.0) (- y t)) (* (/ x (* (- y t) z)) 2.0))) #t TRUE binary64) #s(test "Linear.Projection:inversePerspective from linear-1.19.1.3, B" (x y) (/ (- x y) (* (* x 2.0) y)) (- (/ 0.5 y) (/ 0.5 x)) #t TRUE binary64) #s(test "Linear.Projection:inversePerspective from linear-1.19.1.3, C" (x y) (/ (+ x y) (* (* x 2.0) y)) (+ (/ 0.5 x) (/ 0.5 y)) #t TRUE binary64) #s(test "Linear.Projection:perspective from linear-1.19.1.3, A" (x y) (/ (+ x y) (- x y)) (/ 1 (- (/ x (+ x y)) (/ y (+ x y)))) #t TRUE binary64) #s(test "Linear.Projection:perspective from linear-1.19.1.3, B" (x y) (/ (* (* x 2.0) y) (- x y)) (if (< x -1.7210442634149447e+81) (* (/ (* 2.0 x) (- x y)) y) (if (< x 8.364504563556443e+16) (/ (* x 2.0) (/ (- x y) y)) (* (/ (* 2.0 x) (- x y)) y))) #t TRUE binary64) #s(test "Physics.ForceLayout:coulombForce from force-layout-0.4.0.2" (x y) (/ x (* y y)) (/ (/ x y) y) #t TRUE binary64) #s(test "Codec.Picture.Types:toneMapping from JuicyPixels-3.2.6.1" (x y) (/ (* x (+ (/ x y) 1.0)) (+ x 1.0)) (* (/ x 1) (/ (+ (/ x y) 1.0) (+ x 1.0))) #t TRUE binary64) #s(test "Codec.Picture.Jpg.FastDct:referenceDct from JuicyPixels-3.2.6.1" (x y z t a b) (* (* x (cos (/ (* (* (+ (* y 2.0) 1.0) z) t) 16.0))) (cos (/ (* (* (+ (* a 2.0) 1.0) b) t) 16.0))) (* x (cos (* (/ b 16.0) (/ t (+ (- 1.0 (* a 2.0)) (pow (* a 2.0) 2)))))) #t TRUE binary64) #s(test "Main:i from " (x) (+ (+ (+ (+ x x) x) x) x) #f #t TRUE binary64) #s(test "Main:z from " (x y z t) (+ (+ (+ (- (sqrt (+ x 1.0)) (sqrt x)) (- (sqrt (+ y 1.0)) (sqrt y))) (- (sqrt (+ z 1.0)) (sqrt z))) (- (sqrt (+ t 1.0)) (sqrt t))) (+ (+ (+ (/ 1.0 (+ (sqrt (+ x 1.0)) (sqrt x))) (/ 1.0 (+ (sqrt (+ y 1.0)) (sqrt y)))) (/ 1.0 (+ (sqrt (+ z 1.0)) (sqrt z)))) (- (sqrt (+ t 1.0)) (sqrt t))) #t TRUE binary64) #s(test "Diagrams.ThreeD.Shapes:frustum from diagrams-lib-1.3.0.3, A" (x y z t a b c i) (* 2.0 (- (+ (* x y) (* z t)) (* (* (+ a (* b c)) c) i))) (* 2.0 (- (+ (* x y) (* z t)) (* (+ a (* b c)) (* c i)))) #t TRUE binary64) #s(test "Diagrams.ThreeD.Shapes:frustum from diagrams-lib-1.3.0.3, B" (x y z) (+ x (* (- y x) z)) #f #t TRUE binary64) #s(test "Diagrams.ThreeD.Transform:aboutY from diagrams-lib-1.3.0.3" (x y z) (+ (* x (cos y)) (* z (sin y))) #f #t TRUE binary64) #s(test "Diagrams.ThreeD.Transform:aboutX from diagrams-lib-1.3.0.3, A" (x y z) (- (* x (cos y)) (* z (sin y))) #f #t TRUE binary64) #s(test "Diagrams.ThreeD.Transform:aboutX from diagrams-lib-1.3.0.3, B" (x y z) (+ (* x (sin y)) (* z (cos y))) #f #t TRUE binary64) #s(test "Diagrams.Color.HSV:lerp  from diagrams-contrib-1.3.0.5" (x y z) (+ (* (- 1.0 x) y) (* x z)) (- y (* x (- y z))) #t TRUE binary64) #s(test "Diagrams.TwoD.Segment.Bernstein:evaluateBernstein from diagrams-lib-1.3.0.3" (x y z) (/ (* x (+ (- y z) 1.0)) z) (if (< x -2.71483106713436e-162) (- (* (+ 1 y) (/ x z)) x) (if (< x 3.874108816439546e-197) (* (* x (+ (- y z) 1.0)) (/ 1 z)) (- (* (+ 1 y) (/ x z)) x))) #t TRUE binary64) #s(test "Diagrams.Segment:$catParam from diagrams-lib-1.3.0.3, A" (x y) (* (* (* x 3.0) x) y) (* (* x 3.0) (* x y)) #t TRUE binary64) #s(test "Diagrams.Segment:$catParam from diagrams-lib-1.3.0.3, B" (x y) (* (* (* x 3.0) y) y) (* (* x (* 3.0 y)) y) #t TRUE binary64) #s(test "Diagrams.Segment:$catParam from diagrams-lib-1.3.0.3, C" (x) (* (* x x) x) #f #t TRUE binary64) #s(test "Diagrams.Tangent:$catParam from diagrams-lib-1.3.0.3, D" (x) (* 3.0 (+ (- (* (* x 3.0) x) (* x 4.0)) 1.0)) (+ 3.0 (- (* (* 9.0 x) x) (* 12.0 x))) #t TRUE binary64) #s(test "Diagrams.Tangent:$catParam from diagrams-lib-1.3.0.3, E" (x) (* (* 3.0 (- 2.0 (* x 3.0))) x) (- (* 6.0 x) (* 9.0 (* x x))) #t TRUE binary64) #s(test "Diagrams.Tangent:$catParam from diagrams-lib-1.3.0.3, F" (x) (* (* x 3.0) x) #f #t TRUE binary64) #s(test "Diagrams.Trail:splitAtParam  from diagrams-lib-1.3.0.3, A" (x y z t) (/ (+ x (/ (- (* y z) x) (- (* t z) x))) (+ x 1.0)) (/ (+ x (- (/ y (- t (/ x z))) (/ x (- (* t z) x)))) (+ x 1.0)) #t TRUE binary64) #s(test "Diagrams.Trail:splitAtParam  from diagrams-lib-1.3.0.3, B" (x y) (/ (* x y) (+ y 1.0)) (if (< y -3693.8482788297247) (- (/ x (* y y)) (- (/ x y) x)) (if (< y 6799310503.41891) (/ (* x y) (+ y 1.0)) (- (/ x (* y y)) (- (/ x y) x)))) #t TRUE binary64) #s(test "Diagrams.Trail:splitAtParam  from diagrams-lib-1.3.0.3, C" (x y) (/ (- x y) (- 1.0 y)) #f #t TRUE binary64) #s(test "Diagrams.Trail:splitAtParam  from diagrams-lib-1.3.0.3, D" (x y) (- 1.0 (/ (* (- 1.0 x) y) (+ y 1.0))) (if (< y -3693.8482788297247) (- (/ 1.0 y) (- (/ x y) x)) (if (< y 6799310503.41891) (- 1.0 (/ (* (- 1.0 x) y) (+ y 1.0))) (- (/ 1.0 y) (- (/ x y) x)))) #t TRUE binary64) #s(test "Diagrams.TwoD.Arc:bezierFromSweepQ1 from diagrams-lib-1.3.0.3" (x y) (/ (* (- 1.0 x) (- 3.0 x)) (* y 3.0)) (* (/ (- 1.0 x) y) (/ (- 3.0 x) 3.0)) #t TRUE binary64) #s(test "Diagrams.TwoD.Arc:arcBetween from diagrams-lib-1.3.0.3" (x y) (/ (- (* x x) (* (* y 4.0) y)) (+ (* x x) (* (* y 4.0) y))) (if (< (/ (- (* x x) (* (* y 4.0) y)) (+ (* x x) (* (* y 4.0) y))) 0.9743233849626781) (- (/ (* x x) (+ (* x x) (* (* y y) 4.0))) (/ (* (* y y) 4.0) (+ (* x x) (* (* y y) 4.0)))) (- (pow (/ x (sqrt (+ (* x x) (* (* y y) 4.0)))) 2) (/ (* (* y y) 4.0) (+ (* x x) (* (* y y) 4.0))))) #t TRUE binary64) #s(test "Diagrams.TwoD.Ellipse:ellipse from diagrams-lib-1.3.0.3" (x) (sqrt (- 1.0 (* x x))) #f #t TRUE binary64) #s(test "Graphics.Rendering.Chart.Axis.Types:invLinMap from Chart-1.5.3" (x y z t a) (+ x (/ (* (- y z) (- t x)) (- a z))) (if (< z -1.2536131056095036e+188) (- t (* (/ y z) (- t x))) (if (< z 4.446702369113811e+64) (+ x (/ (- y z) (/ (- a z) (- t x)))) (- t (* (/ y z) (- t x))))) #t TRUE binary64) #s(test "Diagrams.TwoD.Segment:bezierClip from diagrams-lib-1.3.0.3" (x y z) (+ (* x y) (* z (- 1.0 y))) (- z (* (- z x) y)) #t TRUE binary64) #s(test "Data.Octree.Internal:octantDistance  from Octree-0.5.4.2" (x y) (sqrt (+ (* x x) (* y y))) (if (< x -1.1236950826599826e+145) (- x) (if (< x 1.116557621183362e+93) (sqrt (+ (* x x) (* y y))) x)) #t TRUE binary64) #s(test "Graphics.Rasterific.Shading:$sradialGradientWithFocusShader from Rasterific-0.6.1" (x y) (- x (* y y)) #f #t TRUE binary64) #s(test "Diagrams.TwoD.Path.Metafont.Internal:hobbyF from diagrams-contrib-1.3.0.5" (x y) (/ (+ 2.0 (* (* (* (sqrt 2.0) (- (sin x) (/ (sin y) 16.0))) (- (sin y) (/ (sin x) 16.0))) (- (cos x) (cos y)))) (* 3.0 (+ (+ 1.0 (* (/ (- (sqrt 5.0) 1.0) 2.0) (cos x))) (* (/ (- 3.0 (sqrt 5.0)) 2.0) (cos y))))) #f #t TRUE binary64) #s(test "Diagrams.TwoD.Layout.CirclePacking:approxRadius from diagrams-contrib-1.3.0.5" (x y) (/ (tan (/ x (* y 2.0))) (sin (/ x (* y 2.0)))) (if (< y -1.2303690911306994e+114) 1.0 (if (< y -9.102852406811914e-222) (/ (sin (/ x (* y 2.0))) (* (sin (/ x (* y 2.0))) (log (exp (cos (/ x (* y 2.0))))))) 1.0)) #t TRUE binary64) #s(test "Diagrams.TwoD.Apollonian:descartes from diagrams-contrib-1.3.0.5" (x y z) (* 2.0 (sqrt (+ (+ (* x y) (* x z)) (* y z)))) (if (< z 7.636950090573675e+176) (* 2.0 (sqrt (+ (* (+ x y) z) (* x y)))) (* (* (+ (* 1/4 (* (* (pow y -3/4) (* (pow z -3/4) x)) (+ y z))) (* (pow z 1/4) (pow y 1/4))) (+ (* 1/4 (* (* (pow y -3/4) (* (pow z -3/4) x)) (+ y z))) (* (pow z 1/4) (pow y 1/4)))) 2.0)) #t TRUE binary64) #s(test "Diagrams.TwoD.Apollonian:initialConfig from diagrams-contrib-1.3.0.5, A" (x y z) (/ (- (+ (* x x) (* y y)) (* z z)) (* y 2.0)) (- (* y 0.5) (* (* (/ 0.5 y) (+ z x)) (- z x))) #t TRUE binary64) #s(test "Diagrams.TwoD.Apollonian:initialConfig from diagrams-contrib-1.3.0.5, B" (x y z) (* x (sqrt (- (* y y) (* z z)))) (if (< y 2.5816096488251695e-278) (- (* x y)) (* x (* (sqrt (+ y z)) (sqrt (- y z))))) #t TRUE binary64) #s(test "Diagrams.Backend.Rasterific:rasterificRadialGradient from diagrams-rasterific-1.3.1.3" (x y z) (/ (+ x (* y (- z x))) z) (- (+ y (/ x z)) (/ y (/ z x))) #t TRUE binary64) #s(test "Data.HashTable.ST.Basic:computeOverhead from hashtables-1.2.0.2" (x y z t) (+ (/ x y) (/ (+ 2.0 (* (* z 2.0) (- 1.0 t))) (* t z))) (- (/ (+ (/ 2.0 z) 2.0) t) (- 2.0 (/ x y))) #t TRUE binary64) #s(test "Language.Haskell.HsColour.ColourHighlight:unbase from hscolour-1.23" (x y z t) (+ (* (+ (* x y) z) y) t) #f #t TRUE binary64) #s(test "System.Random.MWC.Distributions:blocks from mwc-random-0.13.3.2" (x) (* (* x 0.5) x) #f #t TRUE binary64) #s(test "System.Random.MWC.Distributions:standard from mwc-random-0.13.3.2" (x y) (* 0.5 (- (* x x) y)) #f #t TRUE binary64) #s(test "SynthBasics:oscSampleBasedAux from YampaSynth-0.2" (x y z) (+ x (* y (- z x))) #f #t TRUE binary64) #s(test "System.Random.MWC.Distributions:truncatedExp from mwc-random-0.13.3.2" (x y z t) (- x (/ (log (+ (- 1.0 y) (* y (exp z)))) t)) (if (< z -2.8874623088207947e+119) (- (- x (/ (/ (- 0.5) (* y t)) (* z z))) (* (/ (- 0.5) (* y t)) (/ (/ 2.0 z) (* z z)))) (- x (/ (log (+ 1.0 (* z y))) t))) #t TRUE binary64) #s(test "System.Random.MWC.Distributions:gamma from mwc-random-0.13.3.2" (x y z) (+ (* x 0.5) (* y (+ (- 1.0 z) (log z)))) (- (+ y (* 0.5 x)) (* y (- z (log z)))) #t TRUE binary64) #s(test "AI.Clustering.Hierarchical.Internal:average from clustering-0.2.1, A" (x y) (/ x (+ x y)) #f #t TRUE binary64) #s(test "Numeric.Integration.TanhSinh:nonNegative from integration-0.2.1" (x) (/ x (- 1.0 x)) #f #t TRUE binary64) #s(test "Graphics.Rasterific.QuadraticFormula:discriminant from Rasterific-0.6.1" (x y z) (- (* x x) (* (* y 4.0) z)) #f #t TRUE binary64) #s(test "Graphics.Rasterific.CubicBezier:cachedBezierAt from Rasterific-0.6.1" (x y z t a b) (+ (+ (+ x (* y z)) (* t a)) (* (* a z) b)) (if (< z -1.1820553527347888e+19) (+ (* z (+ (* b a) y)) (+ x (* t a))) (if (< z 4.7589743188364287e-122) (+ (* (+ (* b z) t) a) (+ (* z y) x)) (+ (* z (+ (* b a) y)) (+ x (* t a))))) #t TRUE binary64) #s(test "Graphics.Rasterific.CubicBezier:isSufficientlyFlat from Rasterific-0.6.1" (x) (* (* x 16.0) x) #f #t TRUE binary64) #s(test "Graphics.Rasterific.Shading:$sgradientColorAt from Rasterific-0.6.1" (x y z) (/ (- x y) (- z y)) (- (/ x (- z y)) (/ y (- z y))) #t TRUE binary64) #s(test "Graphics.Rasterific.Shading:$sradialGradientWithFocusShader from Rasterific-0.6.1, A" (x) (+ (* x x) 1.0) #f #t TRUE binary64) #s(test "Graphics.Rasterific.Shading:$sradialGradientWithFocusShader from Rasterific-0.6.1, B" (x y z t) (- (* x x) (* (* y 4.0) (- (* z z) t))) (- (* x x) (* 4.0 (* y (- (* z z) t)))) #t TRUE binary64) #s(test "Data.Number.Erf:$dmerfcx from erf-2.0.0.0" (x y) (* x (exp (* y y))) (* x (pow (exp y) y)) #t TRUE binary64) #s(test "Data.Number.Erf:$cinvnormcdf from erf-2.0.0.0, A" (x y z t) (* (* (- (* x 0.5) y) (sqrt (* z 2.0))) (exp (/ (* t t) 2.0))) (* (* (- (* x 0.5) y) (sqrt (* z 2.0))) (pow (exp 1) (/ (* t t) 2.0))) #t TRUE binary64) #s(test "Data.Number.Erf:$cinvnormcdf from erf-2.0.0.0, B" (x y) (- x (/ y (+ 1.0 (/ (* x y) 2.0)))) #f #t TRUE binary64) #s(test "Numeric.AD.Rank1.Halley:findZero from ad-4.2.4" (x y z t) (- x (/ (* (* y 2.0) z) (- (* (* z 2.0) z) (* y t)))) (- x (/ 1 (- (/ z y) (/ (/ t 2.0) z)))) #t TRUE binary64) #s(test "Crypto.Random.Test:calculate from crypto-random-0.0.9" (x y z) (+ x (/ (* y y) z)) (+ x (* y (/ y z))) #t TRUE binary64) #s(test "Numeric.Log:$cexpm1 from log-domain-0.10.2.1, A" (x) (* (* x 2.0) x) (* (* 2.0 x) x) #t TRUE binary64) #s(test "Numeric.Log:$cexpm1 from log-domain-0.10.2.1, B" (x y) (+ (+ (* x y) x) y) #f #t TRUE binary64) #s(test "Numeric.Log:$clog1p from log-domain-0.10.2.1, A" (x y) (+ (+ (* x 2.0) (* x x)) (* y y)) (+ (* y y) (+ (* 2.0 x) (* x x))) #t TRUE binary64) #s(test "Numeric.Log:$clog1p from log-domain-0.10.2.1, B" (x) (/ x (+ 1.0 (sqrt (+ x 1.0)))) #f #t TRUE binary64) #s(test "Data.Approximate.Numerics:blog from approximate-0.2.2.1" (x) (/ (* 6.0 (- x 1.0)) (+ (+ x 1.0) (* 4.0 (sqrt x)))) (/ 6.0 (/ (+ (+ x 1.0) (* 4.0 (sqrt x))) (- x 1.0))) #t TRUE binary64) #s(test "Graphics.Rasterific.Svg.PathConverter:segmentToBezier from rasterific-svg-0.2.3.1, A" (x) (/ (* (* (/ 8.0 3.0) (sin (* x 0.5))) (sin (* x 0.5))) (sin x)) (/ (/ (* 8.0 (sin (* x 0.5))) 3.0) (/ (sin x) (sin (* x 0.5)))) #t TRUE binary64) #s(test "Graphics.Rasterific.Svg.PathConverter:segmentToBezier from rasterific-svg-0.2.3.1, B" (x y z) (- (+ x (cos y)) (* z (sin y))) #f #t TRUE binary64) #s(test "Graphics.Rasterific.Svg.PathConverter:segmentToBezier from rasterific-svg-0.2.3.1, C" (x y z) (+ (+ x (sin y)) (* z (cos y))) #f #t TRUE binary64) #s(test "Graphics.Rasterific.Svg.PathConverter:arcToSegments from rasterific-svg-0.2.3.1" (x y z t) (+ (/ (* x x) (* y y)) (/ (* z z) (* t t))) (+ (pow (/ x y) 2) (pow (/ z t) 2)) #t TRUE binary64) #s(test "Development.Shake.Profile:generateTrace from shake-0.15.5" (x) (* 1000000.0 (- x x)) 0 #t TRUE binary64) #s(test "Development.Shake.Progress:decay from shake-0.15.5" (x y z t a b) (/ (+ (* x y) (* z (- t a))) (+ y (* z (- b y)))) (- (/ (+ (* z t) (* y x)) (+ y (* z (- b y)))) (/ a (+ (- b y) (/ y z)))) #t TRUE binary64) #s(test "Development.Shake.Progress:message from shake-0.15.5" (x y) (/ (* x 100.0) (+ x y)) (* (/ x 1) (/ 100.0 (+ x y))) #t TRUE binary64) #s(test "Diagrams.Backend.Rasterific:$crender from diagrams-rasterific-1.3.1.3" (x y z) (+ (* x y) (* (- 1.0 x) z)) #f #t TRUE binary64) #s(test "Numeric.Histogram:binBounds from Chart-1.5.3" (x y z t) (+ x (/ (* (- y x) z) t)) (if (< x -9.025511195533005e-135) (- x (* (/ z t) (- x y))) (if (< x 4.275032163700715e-250) (+ x (* (/ (- y x) t) z)) (+ x (/ (- y x) (/ t z))))) #t TRUE binary64) #s(test "Graphics.Rendering.Chart.Drawing:drawTextsR from Chart-1.5.3" (x y z) (+ (* x y) (* (- x 1.0) z)) #f #t TRUE binary64) #s(test "Graphics.Rendering.Chart.Axis.Types:hBufferRect from Chart-1.5.3" (x y) (+ x (/ (- x y) 2.0)) (- (* 1.5 x) (* 0.5 y)) #t TRUE binary64) #s(test "Graphics.Rendering.Chart.Axis.Types:linMap from Chart-1.5.3" (x y z t a) (+ x (/ (* (- y x) (- z t)) (- a t))) (if (< a -1.6153062845442575e-142) (+ x (* (/ (- y x) 1) (/ (- z t) (- a t)))) (if (< a 3.774403170083174e-182) (- y (* (/ z t) (- y x))) (+ x (* (/ (- y x) 1) (/ (- z t) (- a t)))))) #t TRUE binary64) #s(test "Graphics.Rendering.Chart.Plot.Vectors:renderPlotVectors from Chart-1.5.3" (x y) (+ x (* (- 1.0 x) (- 1.0 y))) (- (* y x) (- y 1.0)) #t TRUE binary64) #s(test "Graphics.Rendering.Chart.Plot.AreaSpots:renderSpotLegend from Chart-1.5.3" (x y) (+ x (/ (fabs (- y x)) 2.0)) #f #t TRUE binary64) #s(test "Graphics.Rendering.Chart.Plot.AreaSpots:renderAreaSpots4D from Chart-1.5.3" (x y z t) (/ (* x (- y z)) (- t z)) (/ x (/ (- t z) (- y z))) #t TRUE binary64) #s(test "Graphics.Rendering.Chart.Plot.Pie:renderPie from Chart-1.5.3" (x y) (- (+ x y) x) (- y 0) #t TRUE binary64) #s(test "Graphics.Rendering.Chart.SparkLine:renderSparkLine from Chart-1.5.3" (x y z t a) (- x (/ (- y z) (/ (+ (- t z) 1.0) a))) (- x (* (/ (- y z) (+ (- t z) 1.0)) a)) #t TRUE binary64) #s(test "Graphics.Rendering.Chart.Backend.Diagrams:calcFontMetrics from Chart-diagrams-1.5.1, A" (x y z) (/ (+ x y) (- 1.0 (/ y z))) (if (< y -3.7429310762689856e+171) (* (/ (+ y x) (- y)) z) (if (< y 3.5534662456086734e+168) (/ (+ x y) (- 1.0 (/ y z))) (* (/ (+ y x) (- y)) z))) #t TRUE binary64) #s(test "Graphics.Rendering.Chart.Backend.Diagrams:calcFontMetrics from Chart-diagrams-1.5.1, B" (x y z t) (* x (/ (* (/ y z) t) t)) (if (< (/ (* (/ y z) t) t) -1.20672205123045e+245) (/ y (/ z x)) (if (< (/ (* (/ y z) t) t) -5.907522236933906e-275) (* x (/ y z)) (if (< (/ (* (/ y z) t) t) 5.658954423153415e-65) (/ y (/ z x)) (if (< (/ (* (/ y z) t) t) 2.0087180502407133e+217) (* x (/ y z)) (/ (* y x) z))))) #t TRUE binary64) #s(test "AI.Clustering.Hierarchical.Internal:average from clustering-0.2.1, B" (x y) (/ x (+ y x)) #f #t TRUE binary64) #s(test "AI.Clustering.Hierarchical.Internal:ward from clustering-0.2.1" (x y z t a b) (/ (- (+ (* (+ x y) z) (* (+ t y) a)) (* y b)) (+ (+ x t) y)) (if (< (/ (- (+ (* (+ x y) z) (* (+ t y) a)) (* y b)) (+ (+ x t) y)) -3.5813117084150564e+153) (- (+ z a) b) (if (< (/ (- (+ (* (+ x y) z) (* (+ t y) a)) (* y b)) (+ (+ x t) y)) 1.2285964308315609e+82) (/ 1 (/ (+ (+ x t) y) (- (+ (* (+ x y) z) (* (+ t y) a)) (* y b)))) (- (+ z a) b))) #t TRUE binary64) #s(test "Numeric.SpecFunctions:invErfc from math-functions-0.1.5.2, A" (x y z) (+ x (/ y (- (* 1.1283791670955126 (exp z)) (* x y)))) (+ x (/ 1 (- (* (/ 1.1283791670955126 y) (exp z)) x))) #t TRUE binary64) #s(test "Numeric.SpecFunctions:invErfc from math-functions-0.1.5.2, B" (x) (* 0.70711 (- (/ (+ 2.30753 (* x 0.27061)) (+ 1.0 (* x (+ 0.99229 (* x 0.04481))))) x)) #f #t TRUE binary64) #s(test "Numeric.SpecFunctions:logGamma from math-functions-0.1.5.2, A" (x y) (+ (- (* x (- y 1.0)) (* y 0.5)) 0.918938533204673) #f #t TRUE binary64) #s(test "Numeric.SpecFunctions:logGamma from math-functions-0.1.5.2, B" (x y z) (+ x (/ (* y (+ (* (+ (* z 0.0692910599291889) 0.4917317610505968) z) 0.279195317918525)) (+ (* (+ z 6.012459259764103) z) 3.350343815022304))) (if (< z -8120153.652456675) (- (* (+ (/ 0.07512208616047561 z) 0.0692910599291889) y) (- (/ (* 0.40462203869992125 y) (* z z)) x)) (if (< z 6.576118972787377e+20) (+ x (* (* y (+ (* (+ (* z 0.0692910599291889) 0.4917317610505968) z) 0.279195317918525)) (/ 1 (+ (* (+ z 6.012459259764103) z) 3.350343815022304)))) (- (* (+ (/ 0.07512208616047561 z) 0.0692910599291889) y) (- (/ (* 0.40462203869992125 y) (* z z)) x)))) #t TRUE binary64) #s(test "Numeric.SpecFunctions:logGamma from math-functions-0.1.5.2, C" (x y z) (/ (* (- x 2.0) (+ (* (+ (* (+ (* (+ (* x 4.16438922228) 78.6994924154) x) 137.519416416) x) y) x) z)) (+ (* (+ (* (+ (* (+ x 43.3400022514) x) 263.505074721) x) 313.399215894) x) 47.066876606)) (if (< x -3.326128725870005e+62) (- (+ (/ y (* x x)) (* 4.16438922228 x)) 110.1139242984811) (if (< x 9.429991714554673e+55) (* (/ (- x 2.0) 1) (/ (+ (* (+ (* (+ (* (+ (* x 4.16438922228) 78.6994924154) x) 137.519416416) x) y) x) z) (+ (* (+ (+ (* 263.505074721 x) (+ (* 43.3400022514 (* x x)) (* x (* x x)))) 313.399215894) x) 47.066876606))) (- (+ (/ y (* x x)) (* 4.16438922228 x)) 110.1139242984811))) #t TRUE binary64) #s(test "Numeric.SpecFunctions:logGamma from math-functions-0.1.5.2, D" (x y z t a b) (+ x (/ (* y (+ (* (+ (* (+ (* (+ (* z 3.13060547623) 11.1667541262) z) t) z) a) z) b)) (+ (* (+ (* (+ (* (+ z 15.234687407) z) 31.4690115749) z) 11.9400905721) z) 0.607771387771))) (if (< z -6.499344996252632e+53) (+ x (* (+ (- 3.13060547623 (/ 36.527041698806414 z)) (/ t (* z z))) (/ y 1))) (if (< z 7.066965436914287e+59) (+ x (/ y (/ (+ (* (+ (* (+ (* (+ z 15.234687407) z) 31.4690115749) z) 11.9400905721) z) 0.607771387771) (+ (* (+ (* (+ (* (+ (* z 3.13060547623) 11.1667541262) z) t) z) a) z) b)))) (+ x (* (+ (- 3.13060547623 (/ 36.527041698806414 z)) (/ t (* z z))) (/ y 1))))) #t TRUE binary64) #s(test "Numeric.SpecFunctions:$slogFactorial from math-functions-0.1.5.2, A" (x) (/ 1.0 (* x x)) (/ (/ 1.0 x) x) #t TRUE binary64) #s(test "Numeric.SpecFunctions:$slogFactorial from math-functions-0.1.5.2, B" (x y z) (+ (+ (- (* (- x 0.5) (log x)) x) 0.91893853320467) (/ (+ (* (- (* (+ y 0.0007936500793651) z) 0.0027777777777778) z) 0.083333333333333) x)) (+ (+ (+ (* (- x 0.5) (log x)) (- 0.91893853320467 x)) (/ 0.083333333333333 x)) (* (/ z x) (- (* z (+ y 0.0007936500793651)) 0.0027777777777778))) #t TRUE binary64) #s(test "Numeric.SpecFunctions:logGammaL from math-functions-0.1.5.2" (x y z t a) (+ (- (+ (log (+ x y)) (log z)) t) (* (- a 0.5) (log t))) (+ (log (+ x y)) (+ (- (log z) t) (* (- a 0.5) (log t)))) #t TRUE binary64) #s(test "Numeric.SpecFunctions:logGammaCorrection from math-functions-0.1.5.2" (x) (- (* (* x x) 2.0) 1.0) #f #t TRUE binary64) #s(test "Numeric.SpecFunctions:log1p from math-functions-0.1.5.2, A" (x y) (* x (- 1.0 (* x y))) #f #t TRUE binary64) #s(test "Numeric.SpecFunctions:log1p from math-functions-0.1.5.2, B" (x) (* x (- 1.0 (* x 0.5))) #f #t TRUE binary64) #s(test "Numeric.SpecFunctions:logBeta from math-functions-0.1.5.2, A" (x y z t a b) (+ (- (+ (+ x y) z) (* z (log t))) (* (- a 0.5) b)) (+ (+ (+ x y) (/ (* (- 1 (pow (log t) 2)) z) (+ 1 (log t)))) (* (- a 0.5) b)) #t TRUE binary64) #s(test "Numeric.SpecFunctions:logBeta from math-functions-0.1.5.2, B" (x y z t a b c i) (+ (+ (+ (+ (+ (* x (log y)) z) t) a) (* (- b 0.5) (log c))) (* y i)) #f #t TRUE binary64) #s(test "Numeric.SpecFunctions:choose from math-functions-0.1.5.2" (x y z) (/ (* x (+ y z)) z) (/ x (/ z (+ y z))) #t TRUE binary64) #s(test "Numeric.SpecFunctions:stirlingError from math-functions-0.1.5.2" (x y z) (- (+ (- x (* (+ y 0.5) (log y))) y) z) (- (- (+ y x) z) (* (+ y 0.5) (log y))) #t TRUE binary64) #s(test "Numeric.SpecFunctions:incompleteGamma from math-functions-0.1.5.2, A" (x y z t) (+ (- (- (* x (log y)) y) z) (log t)) #f #t TRUE binary64) #s(test "Numeric.SpecFunctions:incompleteGamma from math-functions-0.1.5.2, B" (x y) (* (* 3.0 (sqrt x)) (- (+ y (/ 1.0 (* x 9.0))) 1.0)) (* 3.0 (+ (* y (sqrt x)) (* (- (/ 1.0 (* x 9.0)) 1.0) (sqrt x)))) #t TRUE binary64) #s(test "Numeric.SpecFunctions:invIncompleteGamma from math-functions-0.1.5.2, A" (x) (- 1.0 (* x (+ 0.253 (* x 0.12)))) #f #t TRUE binary64) #s(test "Numeric.SpecFunctions:invIncompleteGamma from math-functions-0.1.5.2, B" (x y) (- 1.0 (log (- 1.0 (/ (- x y) (- 1.0 y))))) (if (< y -81284752.61947241) (- 1.0 (log (- (/ x (* y y)) (- (/ 1.0 y) (/ x y))))) (if (< y 3.0094271212461764e+25) (log (/ (exp 1.0) (- 1.0 (/ (- x y) (- 1.0 y))))) (- 1.0 (log (- (/ x (* y y)) (- (/ 1.0 y) (/ x y))))))) #t TRUE binary64) #s(test "Numeric.SpecFunctions:invIncompleteGamma from math-functions-0.1.5.2, C" (x) (- (/ (+ 2.30753 (* x 0.27061)) (+ 1.0 (* x (+ 0.99229 (* x 0.04481))))) x) #f #t TRUE binary64) #s(test "Numeric.SpecFunctions:invIncompleteGamma from math-functions-0.1.5.2, D" (x y) (- (- 1.0 (/ 1.0 (* x 9.0))) (/ y (* 3.0 (sqrt x)))) (- (- 1.0 (/ (/ 1.0 x) 9.0)) (/ y (* 3.0 (sqrt x)))) #t TRUE binary64) #s(test "Numeric.SpecFunctions:incompleteBetaApprox from math-functions-0.1.5.2, A" (x y) (/ (* x y) (* (* (+ x y) (+ x y)) (+ (+ x y) 1.0))) (/ (/ (/ x (+ (+ y 1) x)) (+ y x)) (/ 1 (/ y (+ y x)))) #t TRUE binary64) #s(test "Numeric.SpecFunctions:incompleteBetaApprox from math-functions-0.1.5.2, B" (x y z t a b) (* x (exp (+ (* y (- (log z) t)) (* a (- (log (- 1.0 z)) b))))) #f #t TRUE binary64) #s(test "Numeric.SpecFunctions:incompleteBetaWorker from math-functions-0.1.5.2, A" (x y z t a b) (/ (* x (exp (- (+ (* y (log z)) (* (- t 1.0) (log a))) b))) y) (if (< t -0.8845848504127471) (/ (* x (/ (pow a (- t 1.0)) y)) (- (+ b 1) (* y (log z)))) (if (< t 852031.2288374073) (/ (* (/ x y) (pow a (- t 1.0))) (exp (- b (* (log z) y)))) (/ (* x (/ (pow a (- t 1.0)) y)) (- (+ b 1) (* y (log z)))))) #t TRUE binary64) #s(test "Numeric.SpecFunctions:invIncompleteBetaWorker from math-functions-0.1.5.2, B" (x y z t) (- (+ (* x (log y)) (* z (log (- 1.0 y)))) t) (- (* (- z) (+ (+ (* 0.5 (* y y)) y) (* (/ 1/3 (* 1.0 (* 1.0 1.0))) (* y (* y y))))) (- t (* x (log y)))) #t TRUE binary64) #s(test "Numeric.SpecFunctions:invIncompleteBetaWorker from math-functions-0.1.5.2, C" (x y z t) (* x (- (/ y z) (/ t (- 1.0 z)))) (if (< (* x (- (/ y z) (/ t (- 1.0 z)))) -7.623226303312042e-196) (* x (- (/ y z) (* t (/ 1 (- 1.0 z))))) (if (< (* x (- (/ y z) (/ t (- 1.0 z)))) 1.4133944927702302e-211) (+ (/ (* y x) z) (- (/ (* t x) (- 1.0 z)))) (* x (- (/ y z) (* t (/ 1 (- 1.0 z))))))) #t TRUE binary64) #s(test "Numeric.SpecFunctions:invIncompleteBetaWorker from math-functions-0.1.5.2, D" (x) (- x (/ (+ 2.30753 (* x 0.27061)) (+ 1.0 (* (+ 0.99229 (* x 0.04481)) x)))) #f #t TRUE binary64) #s(test "Numeric.SpecFunctions:invIncompleteBetaWorker from math-functions-0.1.5.2, E" (x y) (+ (- 1.0 x) (* y (sqrt x))) #f #t TRUE binary64) #s(test "Numeric.SpecFunctions:invIncompleteBetaWorker from math-functions-0.1.5.2, F" (x y) (/ (exp (* x (log (/ x (+ x y))))) x) (if (< y -3.7311844206647956e+94) (/ (exp (/ -1 y)) x) (if (< y 2.817959242728288e+37) (/ (pow (/ x (+ y x)) x) x) (if (< y 2.347387415166998e+178) (log (exp (/ (pow (/ x (+ y x)) x) x))) (/ (exp (/ -1 y)) x)))) #t TRUE binary64) #s(test "Numeric.SpecFunctions:invIncompleteBetaWorker from math-functions-0.1.5.2, G" (x y z) (+ x (/ (exp (* y (log (/ y (+ z y))))) y)) (if (< (/ y (+ z y)) 7.1154157597908e-315) (+ x (/ (exp (/ -1 z)) y)) (+ x (/ (exp (log (pow (/ y (+ y z)) y))) y))) #t TRUE binary64) #s(test "Numeric.SpecFunctions:invIncompleteBetaWorker from math-functions-0.1.5.2, H" (x) (/ (- (* x x) 3.0) 6.0) #f #t TRUE binary64) #s(test "Numeric.SpecFunctions:invIncompleteBetaWorker from math-functions-0.1.5.2, I" (x y z t a b c) (/ x (+ x (* y (exp (* 2.0 (- (/ (* z (sqrt (+ t a))) t) (* (- b c) (- (+ a (/ 5.0 6.0)) (/ 2.0 (* t 3.0)))))))))) (if (< t -2.118326644891581e-50) (/ x (+ x (* y (exp (* 2.0 (- (+ (* a c) (* 0.8333333333333334 c)) (* a b))))))) (if (< t 5.196588770651547e-123) (/ x (+ x (* y (exp (* 2.0 (/ (- (* (* z (sqrt (+ t a))) (* (* 3.0 t) (- a (/ 5.0 6.0)))) (* (- (* (+ (/ 5.0 6.0) a) (* 3.0 t)) 2.0) (* (- a (/ 5.0 6.0)) (* (- b c) t)))) (* (* (* t t) 3.0) (- a (/ 5.0 6.0))))))))) (/ x (+ x (* y (exp (* 2.0 (- (/ (* z (sqrt (+ t a))) t) (* (- b c) (- (+ a (/ 5.0 6.0)) (/ 2.0 (* t 3.0)))))))))))) #t TRUE binary64) #s(test "Numeric.SpecFunctions.Extra:bd0 from math-functions-0.1.5.2" (x y z) (- (* x (log (/ x y))) z) (if (< y 7.595077799083773e-308) (- (* x (log (/ x y))) z) (- (* x (- (log x) (log y))) z)) #t TRUE binary64) #s(test "Numeric.SpecFunctions:logGamma from math-functions-0.1.5.2" (x y z t a b c i) (/ (+ (* (+ (* (+ (* (+ (* x y) z) y) 27464.7644705) y) 230661.510616) y) t) (+ (* (+ (* (+ (* (+ y a) y) b) y) c) y) i)) #f #t TRUE binary64) #s(test "Statistics.Math.RootFinding:ridders from math-functions-0.1.5.2" (x y z t a) (/ (* (* x y) z) (sqrt (- (* z z) (* t a)))) (if (< z -3.1921305903852764e+46) (- (* y x)) (if (< z 5.976268120920894e+90) (/ (* x z) (/ (sqrt (- (* z z) (* a t))) y)) (* y x))) #t TRUE binary64) #s(test "Statistics.Distribution.Poisson.Internal:probability from math-functions-0.1.5.2" (x y z) (exp (- (+ x (* y (log y))) z)) (exp (+ (- x z) (* (log y) y))) #t TRUE binary64) #s(test "Statistics.Distribution.Binomial:directEntropy from math-functions-0.1.5.2" (x) (* x (log x)) #f #t TRUE binary64) #s(test "Statistics.Correlation.Kendall:numOfTiesBy from math-functions-0.1.5.2" (x) (* x (- x 1.0)) (- (* x x) x) #t TRUE binary64) #s(test "Statistics.Sample:robustSumVarWeighted from math-functions-0.1.5.2" (x y z) (+ x (* (* y z) z)) #f #t TRUE binary64) #s(test "Statistics.Sample:$swelfordMean from math-functions-0.1.5.2" (x y z) (+ x (/ (- y x) z)) #f #t TRUE binary64) #s(test "Statistics.Sample:$skurtosis from math-functions-0.1.5.2" (x y) (- (/ x (* y y)) 3.0) (- (/ (/ x y) y) 3.0) #t TRUE binary64) #s(test "Statistics.Distribution.Beta:$centropy from math-functions-0.1.5.2" (x y z t a b) (+ (- (- x (* (- y 1.0) z)) (* (- t 1.0) a)) (* (- (+ y t) 2.0) b)) #f #t TRUE binary64) #s(test "Statistics.Distribution.Beta:$cvariance from math-functions-0.1.5.2" (x y z) (/ (* x y) (* (* z z) (+ z 1.0))) (if (< z 249.6182814532307) (/ (* y (/ x z)) (+ z (* z z))) (/ (* (/ (/ y z) (+ 1 z)) x) z)) #t TRUE binary64) #s(test "Statistics.Distribution.Beta:$cdensity from math-functions-0.1.5.2" (x y z t) (- (+ (* (- x 1.0) (log y)) (* (- z 1.0) (log (- 1.0 y)))) t) #f #t TRUE binary64) #s(test "Statistics.Distribution.Binomial:$cvariance from math-functions-0.1.5.2" (x y) (* (* x y) (- 1.0 y)) #f #t TRUE binary64) #s(test "Statistics.Distribution.Poisson:$clogProbability from math-functions-0.1.5.2" (x y z) (- (- (* x (log y)) z) y) #f #t TRUE binary64) #s(test "Statistics.Distribution.CauchyLorentz:$cdensity from math-functions-0.1.5.2" (x y z) (/ (/ 1.0 x) (* y (+ 1.0 (* z z)))) (if (< (* y (+ 1.0 (* z z))) -inf.0) (/ (/ 1.0 y) (* (+ 1.0 (* z z)) x)) (if (< (* y (+ 1.0 (* z z))) 8.680743250567252e+305) (/ (/ 1.0 x) (* (+ 1.0 (* z z)) y)) (/ (/ 1.0 y) (* (+ 1.0 (* z z)) x)))) #t TRUE binary64) #s(test "Examples.Basics.BasicTests:f3 from sbv-4.4" (x y) (* (+ x y) (+ x y)) (+ (* x x) (+ (* y y) (* 2 (* y x)))) #t TRUE binary64) #s(test "Examples.Basics.BasicTests:f2 from sbv-4.4" (x y) (- (* x x) (* y y)) #f #t TRUE binary64) #s(test "Examples.Basics.BasicTests:f1 from sbv-4.4" (x y) (* (+ x y) (- x y)) #f #t TRUE binary64) #s(test "Examples.Basics.ProofTests:f4 from sbv-4.4" (x y) (+ (+ (* x x) (* (* x 2.0) y)) (* y y)) (+ (* x x) (+ (* y y) (* (* x y) 2.0))) #t TRUE binary64) #s(test "Numeric.LinearAlgebra.Util:formatSparse from hmatrix-0.16.1.5" (x y) (/ (fabs (- x y)) (fabs y)) #f #t TRUE binary64) #s(test "Data.Random.Distribution.Normal:normalF from random-fu-0.2.6.2" (x y) (exp (* (* x y) y)) #f #t TRUE binary64) #s(test "Data.Random.Distribution.Normal:normalTail from random-fu-0.2.6.2" (x y) (+ (+ (* x x) y) y) (+ (+ y y) (* x x)) #t TRUE binary64) #s(test "Data.Random.Distribution.Normal:doubleStdNormalZ from random-fu-0.2.6.2" (x) (- (+ x x) 1.0) #f #t TRUE binary64) #s(test "Data.Random.Distribution.T:$ccdf from random-fu-0.2.6.2" (x y) (/ (+ x y) (+ y y)) (+ (* 1/2 (/ x y)) 1/2) #t TRUE binary64) #s(test "Data.Random.Distribution.Triangular:triangularCDF from random-fu-0.2.6.2, A" (x y z t) (- 1.0 (/ x (* (- y z) (- y t)))) #f #t TRUE binary64) #s(test "Data.Random.Distribution.Triangular:triangularCDF from random-fu-0.2.6.2, B" (x y z t) (/ x (* (- y z) (- t z))) (if (< (/ x (* (- y z) (- t z))) 0.0) (/ (/ x (- y z)) (- t z)) (* x (/ 1 (* (- y z) (- t z))))) #t TRUE binary64) #s(test "Data.Random.Dice:roll from dice-0.1" (x) (- (* x x) 1.0) #f #t TRUE binary64) #s(test "Prelude:atanh from fay-base-0.20.0.1" (x) (/ (+ x 1.0) (- 1.0 x)) #f #t TRUE binary64) #s(test "ReportTypes:explainFloat from gipeda-0.1.2.1" (x) (* 100.0 (/ (- x x) x)) 0 #t TRUE binary64) #s(test "Hakyll.Web.Tags:renderTagCloud from hakyll-4.7.2.3" (x y z t a) (+ x (* (/ (- y z) (- (+ t 1.0) z)) (- a x))) #f #t TRUE binary64) #s(test "Data.Histogram.Bin.BinF:$cfromIndex from histogram-fill-0.8.4.1" (x y z) (+ (+ (/ x 2.0) (* y x)) z) #f #t TRUE binary64) #s(test "Data.Histogram.Bin.LogBinD:$cbinSizeN from histogram-fill-0.8.4.1" (x y) (- (* x y) x) #f #t TRUE binary64) #s(test "Numeric.Signal:interpolate   from hsignal-0.2.7.1" (x y z t a) (+ x (* (- y z) (/ (- t x) (- a z)))) #f #t TRUE binary64) #s(test "Numeric.Signal.Multichannel:$cget from hsignal-0.2.7.1" (x y z t) (+ (* (/ x y) (- z t)) t) (if (< z 2.759456554562692e-282) (+ (* (/ x y) (- z t)) t) (if (< z 2.326994450874436e-110) (+ (* x (/ (- z t) y)) t) (+ (* (/ x y) (- z t)) t))) #t TRUE binary64) #s(test "Numeric.Signal.Multichannel:$cput from hsignal-0.2.7.1" (x y z t) (* (/ (- x y) (- z y)) t) (/ t (/ (- z y) (- x y))) #t TRUE binary64) #s(test "Data.HyperLogLog.Config:hll from hyperloglog-0.3.4" (x y) (* (* x y) y) #f #t TRUE binary64) #s(test "Data.HyperLogLog.Type:size from hyperloglog-0.3.4, A" (x y) (* (* x 1.0) (log (- 1.0 (/ y x)))) (* x (log (- 1.0 (/ y x)))) #t TRUE binary64) #s(test "Data.HyperLogLog.Type:size from hyperloglog-0.3.4, B" (x y) (* x (log (/ x y))) (if (< y 1.2973149052617803e-303) (* x (log (/ x y))) (/ x (/ 1 (- (log x) (log y))))) #t TRUE binary64) #s(test "Diagrams.Backend.Cairo.Internal:setTexture from diagrams-cairo-1.3.0.3" (x y z) (/ (* x (- y z)) y) (if (< z -2.060202331921739e+104) (- x (/ (* z x) y)) (if (< z 1.6939766013828526e+213) (/ x (/ y (- y z))) (* (- y z) (/ x y)))) #t TRUE binary64) #s(test "Numeric.Integration.TanhSinh:simpson  from integration-0.2.1" (x y) (* x (+ y y)) #f #t TRUE binary64) #s(test "Numeric.Integration.TanhSinh:everywhere from integration-0.2.1" (x y) (* x (+ 1.0 (* y y))) (+ x (* (* x y) y)) #t TRUE binary64) #s(test "Data.Metrics.Snapshot:quantile from metrics-0.3.0.2" (x y z t) (+ x (* (- y z) (- t x))) (+ x (+ (* t (- y z)) (* (- x) (- y z)))) #t TRUE binary64) #s(test "Graphics.Rendering.Plot.Render.Plot.Legend:renderLegendOutside from plot-0.2.3.4, A" (x y) (+ (+ x y) x) (+ y (* 2 x)) #t TRUE binary64) #s(test "Graphics.Rendering.Plot.Render.Plot.Legend:renderLegendOutside from plot-0.2.3.4, B" (x y z t) (+ (* x (+ (+ (+ (+ y z) z) y) t)) (* y 5.0)) #f #t TRUE binary64) #s(test "Graphics.Rendering.Plot.Render.Plot.Legend:renderLegendInside from plot-0.2.3.4" (x y z) (+ (+ (+ (+ (+ x y) y) x) z) x) #f #t TRUE binary64) #s(test "Graphics.Rendering.Plot.Render.Plot.Legend:renderLegendOutside from plot-0.2.3.4, C" (x y z) (+ (* x (+ y z)) (* z 5.0)) (+ (* (+ x 5.0) z) (* x y)) #t TRUE binary64) #s(test "Graphics.Rendering.Plot.Render.Plot.Axis:tickPosition from plot-0.2.3.4" (x y z t) (+ x (* (- y x) (/ z t))) (if (< (* (- y x) (/ z t)) -1013646692435.8867) (+ x (/ (- y x) (/ t z))) (if (< (* (- y x) (/ z t)) -0.0) (+ x (/ (* (- y x) z) t)) (+ x (/ (- y x) (/ t z))))) #t TRUE binary64) #s(test "Graphics.Rendering.Plot.Render.Plot.Axis:renderAxisLine from plot-0.2.3.4, A" (x y z t a) (+ x (* y (/ (- z t) (- z a)))) (+ x (/ y (/ (- z a) (- z t)))) #t TRUE binary64) #s(test "Graphics.Rendering.Plot.Render.Plot.Axis:renderAxisLine from plot-0.2.3.4, B" (x y z t a) (+ x (* y (/ (- z t) (- a t)))) (if (< y -8.508084860551241e-17) (+ x (* y (/ (- z t) (- a t)))) (if (< y 2.894426862792089e-49) (+ x (* (* y (- z t)) (/ 1 (- a t)))) (+ x (* y (/ (- z t) (- a t)))))) #t TRUE binary64) #s(test "Graphics.Rendering.Plot.Render.Plot.Axis:renderAxisTick from plot-0.2.3.4, A" (x y z t a) (+ x (/ (* (- y z) t) (- a z))) (if (< t -1.0682974490174067e-39) (+ x (* (/ (- y z) (- a z)) t)) (if (< t 3.9110949887586375e-141) (+ x (/ (* (- y z) t) (- a z))) (+ x (* (/ (- y z) (- a z)) t)))) #t TRUE binary64) #s(test "Graphics.Rendering.Plot.Render.Plot.Axis:renderAxisTick from plot-0.2.3.4, B" (x y z t a) (- (+ x y) (/ (* (- z t) y) (- a t))) (if (< (- (+ x y) (/ (* (- z t) y) (- a t))) -1.3664970889390727e-07) (- (+ y x) (* (* (- z t) (/ 1 (- a t))) y)) (if (< (- (+ x y) (/ (* (- z t) y) (- a t))) 1.4754293444577233e-239) (/ (- (* y (- a z)) (* x t)) (- a t)) (- (+ y x) (* (* (- z t) (/ 1 (- a t))) y)))) #t TRUE binary64) #s(test "Graphics.Rendering.Plot.Render.Plot.Axis:renderAxisTicks from plot-0.2.3.4, A" (x y z t a) (+ x (/ (* y (- z t)) (- z a))) (+ x (/ y (/ (- z a) (- z t)))) #t TRUE binary64) #s(test "Graphics.Rendering.Plot.Render.Plot.Axis:renderAxisTicks from plot-0.2.3.4, B" (x y z t a) (+ x (/ (* y (- z t)) (- a t))) (+ x (/ y (/ (- a t) (- z t)))) #t TRUE binary64) #s(test "Data.Array.Repa.Algorithms.Pixel:doubleRmsOfRGB8 from repa-algorithms-3.4.0.1" (x y z) (sqrt (/ (+ (+ (* x x) (* y y)) (* z z)) 3.0)) (if (< z -6.396479394109776e+136) (/ (- z) (sqrt 3.0)) (if (< z 7.320293694404182e+117) (/ (sqrt (+ (+ (* z z) (* x x)) (* y y))) (sqrt 3.0)) (* (sqrt 0.3333333333333333) z))) #t TRUE binary64) #s(test "Data.Array.Repa.Algorithms.ColorRamp:rampColorHotToCold from repa-algorithms-3.4.0.1, A" (x y z) (+ 1.0 (/ (* 4.0 (- (+ x (* y 0.75)) z)) y)) #f #t TRUE binary64) #s(test "Data.Array.Repa.Algorithms.ColorRamp:rampColorHotToCold from repa-algorithms-3.4.0.1, B" (x y z) (/ (* 4.0 (- (- x y) (* z 0.5))) z) (- (* 4.0 (/ x z)) (+ 2.0 (* 4.0 (/ y z)))) #t TRUE binary64) #s(test "Data.Array.Repa.Algorithms.ColorRamp:rampColorHotToCold from repa-algorithms-3.4.0.1, C" (x y z) (+ 1.0 (/ (* 4.0 (- (+ x (* y 0.25)) z)) y)) #f #t TRUE binary64) #s(test "Data.Spline.Key:interpolateKeys from smoothie-0.4.0.2" (x) (* (* x x) (- 3.0 (* x 2.0))) (* x (* x (- 3.0 (* x 2.0)))) #t TRUE binary64) #s(test "FRP.Yampa.Vector3:vector3Rho from Yampa-0.10.2" (x y z) (sqrt (+ (+ (* x x) (* y y)) (* z z))) (if (< z -6.396479394109776e+136) (- z) (if (< z 7.320293694404182e+117) (sqrt (+ (+ (* z z) (* x x)) (* y y))) z)) #t TRUE binary64) #s(test "SynthBasics:moogVCF from YampaSynth-0.2" (x y z t) (+ x (* (* y z) (- (tanh (/ t y)) (tanh (/ x y))))) (+ x (* y (* z (- (tanh (/ t y)) (tanh (/ x y)))))) #t TRUE binary64) #s(test "FastMath dist" (d1 d2 d3) (+ (* d1 d2) (* d1 d3)) (* d1 (+ d2 d3)) #t TRUE binary64) #s(test "FastMath test1" (d) (+ (* d 10) (* d 20)) (* d 30) #t TRUE binary64) #s(test "FastMath test2" (d1 d2) (+ (+ (* d1 10) (* d1 d2)) (* d1 20)) (* d1 (+ 30 d2)) #t TRUE binary64) #s(test "FastMath dist3" (d1 d2 d3) (+ (+ (* d1 d2) (* (+ d3 5) d1)) (* d1 32)) (* d1 (+ (+ 37 d3) d2)) #t TRUE binary64) #s(test "FastMath dist4" (d1 d2 d3 d4) (- (+ (- (* d1 d2) (* d1 d3)) (* d4 d1)) (* d1 d1)) (* d1 (- (+ (- d2 d3) d4) d1)) #t TRUE binary64) #s(test "FastMath test3" (d1 d2 d3) (+ (+ (* d1 3) (* d1 d2)) (* d1 d3)) (* d1 (+ (+ 3 d2) d3)) #t TRUE binary64) #s(test "FastMath repmul" (d1) (* (* (* d1 d1) d1) d1) (pow d1 4) #t TRUE binary64) #s(test "FastMath test5" (d1) (* (* d1 (* (* (* (* (* d1 (* d1 d1)) d1) d1) (* d1 d1)) d1)) d1) (pow d1 10) #t TRUE binary64) #s(test "Jmat.Real.gamma, branch z greater than 0.5" (z) (* (* (* (sqrt (* PI 2)) (pow (+ (+ (- z 1) 7) 0.5) (+ (- z 1) 0.5))) (exp (- (+ (+ (- z 1) 7) 0.5)))) (+ (+ (+ (+ (+ (+ (+ (+ 0.9999999999998099 (/ 676.5203681218851 (+ (- z 1) 1))) (/ -1259.1392167224028 (+ (- z 1) 2))) (/ 771.3234287776531 (+ (- z 1) 3))) (/ -176.6150291621406 (+ (- z 1) 4))) (/ 12.507343278686905 (+ (- z 1) 5))) (/ -0.13857109526572012 (+ (- z 1) 6))) (/ 9.984369578019572e-06 (+ (- z 1) 7))) (/ 1.5056327351493116e-07 (+ (- z 1) 8)))) #f #t TRUE binary64) #s(test "Jmat.Real.gamma, branch z less than 0.5" (z) (* (/ PI (sin (* PI z))) (* (* (* (sqrt (* PI 2)) (pow (+ (+ (- (- 1 z) 1) 7) 0.5) (+ (- (- 1 z) 1) 0.5))) (exp (- (+ (+ (- (- 1 z) 1) 7) 0.5)))) (+ (+ (+ (+ (+ (+ (+ (+ 0.9999999999998099 (/ 676.5203681218851 (+ (- (- 1 z) 1) 1))) (/ -1259.1392167224028 (+ (- (- 1 z) 1) 2))) (/ 771.3234287776531 (+ (- (- 1 z) 1) 3))) (/ -176.6150291621406 (+ (- (- 1 z) 1) 4))) (/ 12.507343278686905 (+ (- (- 1 z) 1) 5))) (/ -0.13857109526572012 (+ (- (- 1 z) 1) 6))) (/ 9.984369578019572e-06 (+ (- (- 1 z) 1) 7))) (/ 1.5056327351493116e-07 (+ (- (- 1 z) 1) 8))))) #f #t TRUE binary64) #s(test "Jmat.Real.lambertw, estimator" (x) (- (log x) (log (log x))) #f #t TRUE binary64) #s(test "Jmat.Real.lambertw, newton loop step" (wj x) (- wj (/ (- (* wj (exp wj)) x) (+ (exp wj) (* wj (exp wj))))) (- wj (- (/ wj (+ wj 1)) (/ x (+ (exp wj) (* wj (exp wj)))))) #t TRUE binary64) #s(test "Jmat.Real.dawson" (x) (* (/ (+ (+ (+ (+ (+ 1 (* 0.1049934947 (* x x))) (* 0.0424060604 (* (* x x) (* x x)))) (* 0.0072644182 (* (* (* x x) (* x x)) (* x x)))) (* 0.0005064034 (* (* (* (* x x) (* x x)) (* x x)) (* x x)))) (* 0.0001789971 (* (* (* (* (* x x) (* x x)) (* x x)) (* x x)) (* x x)))) (+ (+ (+ (+ (+ (+ 1 (* 0.7715471019 (* x x))) (* 0.2909738639 (* (* x x) (* x x)))) (* 0.0694555761 (* (* (* x x) (* x x)) (* x x)))) (* 0.0140005442 (* (* (* (* x x) (* x x)) (* x x)) (* x x)))) (* 0.0008327945 (* (* (* (* (* x x) (* x x)) (* x x)) (* x x)) (* x x)))) (* (* 2 0.0001789971) (* (* (* (* (* (* x x) (* x x)) (* x x)) (* x x)) (* x x)) (* x x))))) x) #f #t TRUE binary64) #s(test "Jmat.Real.erfi, branch x less than or equal to 0.5" (x) (fabs (* (/ 1 (sqrt PI)) (+ (+ (+ (* 2 (fabs x)) (* (/ 2 3) (* (* (fabs x) (fabs x)) (fabs x)))) (* (/ 1 5) (* (* (* (* (fabs x) (fabs x)) (fabs x)) (fabs x)) (fabs x)))) (* (/ 1 21) (* (* (* (* (* (* (fabs x) (fabs x)) (fabs x)) (fabs x)) (fabs x)) (fabs x)) (fabs x)))))) #f #t TRUE binary64) #s(test "Jmat.Real.erfi, branch x greater than or equal to 5" (x) (* (* (/ 1 (sqrt PI)) (exp (* (fabs x) (fabs x)))) (+ (+ (+ (/ 1 (fabs x)) (* (/ 1 2) (* (* (/ 1 (fabs x)) (/ 1 (fabs x))) (/ 1 (fabs x))))) (* (/ 3 4) (* (* (* (* (/ 1 (fabs x)) (/ 1 (fabs x))) (/ 1 (fabs x))) (/ 1 (fabs x))) (/ 1 (fabs x))))) (* (/ 15 8) (* (* (* (* (* (* (/ 1 (fabs x)) (/ 1 (fabs x))) (/ 1 (fabs x))) (/ 1 (fabs x))) (/ 1 (fabs x))) (/ 1 (fabs x))) (/ 1 (fabs x)))))) #f #t TRUE binary64) #s(test "Jmat.Real.erf" (x) (- 1 (* (* (/ 1 (+ 1 (* 0.3275911 (fabs x)))) (+ 0.254829592 (* (/ 1 (+ 1 (* 0.3275911 (fabs x)))) (+ -0.284496736 (* (/ 1 (+ 1 (* 0.3275911 (fabs x)))) (+ 1.421413741 (* (/ 1 (+ 1 (* 0.3275911 (fabs x)))) (+ -1.453152027 (* (/ 1 (+ 1 (* 0.3275911 (fabs x)))) 1.061405429))))))))) (exp (- (* (fabs x) (fabs x)))))) #f #t TRUE binary64) #s(test "math.abs on complex" (re im) (sqrt (+ (* re re) (* im im))) #f #t TRUE binary64) #s(test "math.cube on real" (x) (* (* x x) x) (pow x 3) #t TRUE binary64) #s(test "math.cube on complex, real part" (x.re x.im) (- (* (- (* x.re x.re) (* x.im x.im)) x.re) (* (+ (* x.re x.im) (* x.im x.re)) x.im)) (+ (* (* x.re x.re) (- x.re x.im)) (* (* x.re x.im) (- x.re (* 3 x.im)))) #t TRUE binary64) #s(test "math.cube on complex, imaginary part" (x.re x.im) (+ (* (- (* x.re x.re) (* x.im x.im)) x.im) (* (+ (* x.re x.im) (* x.im x.re)) x.re)) (+ (* (* x.re x.im) (* 2 x.re)) (* (* x.im (- x.re x.im)) (+ x.re x.im))) #t TRUE binary64) #s(test "_divideComplex, real part" (x.re x.im y.re y.im) (/ (+ (* x.re y.re) (* x.im y.im)) (+ (* y.re y.re) (* y.im y.im))) #f #t TRUE binary64) #s(test "_divideComplex, imaginary part" (x.re x.im y.re y.im) (/ (- (* x.im y.re) (* x.re y.im)) (+ (* y.re y.re) (* y.im y.im))) #f #t TRUE binary64) #s(test "math.exp on complex, real part" (re im) (* (exp re) (cos im)) #f #t TRUE binary64) #s(test "math.exp on complex, imaginary part" (re im) (* (exp re) (sin im)) #f #t TRUE binary64) #s(test "math.log/1 on complex, real part" (re im) (log (sqrt (+ (* re re) (* im im)))) #f #t TRUE binary64) #s(test "math.log/1 on complex, imaginary part" (re im) (atan2 im re) #f #t TRUE binary64) #s(test "math.log/2 on complex, real part" (re im base) (/ (+ (* (log (sqrt (+ (* re re) (* im im)))) (log base)) (* (atan2 im re) 0)) (+ (* (log base) (log base)) (* 0 0))) #f #t TRUE binary64) #s(test "math.log/2 on complex, imaginary part" (re im base) (/ (- (* (atan2 im re) (log base)) (* (log (sqrt (+ (* re re) (* im im)))) 0)) (+ (* (log base) (log base)) (* 0 0))) #f #t TRUE binary64) #s(test "math.log10 on complex, real part" (re im) (/ (log (sqrt (+ (* re re) (* im im)))) (log 10)) #f #t TRUE binary64) #s(test "math.log10 on complex, imaginary part" (re im) (/ (atan2 im re) (log 10)) #f #t TRUE binary64) #s(test "_multiplyComplex, real part" (x.re x.im y.re y.im) (- (* x.re y.re) (* x.im y.im)) #f #t TRUE binary64) #s(test "_multiplyComplex, imaginary part" (x.re x.im y.re y.im) (+ (* x.re y.im) (* x.im y.re)) #f #t TRUE binary64) #s(test "powComplex, real part" (x.re x.im y.re y.im) (* (exp (- (* (log (sqrt (+ (* x.re x.re) (* x.im x.im)))) y.re) (* (atan2 x.im x.re) y.im))) (cos (+ (* (log (sqrt (+ (* x.re x.re) (* x.im x.im)))) y.im) (* (atan2 x.im x.re) y.re)))) #f #t TRUE binary64) #s(test "powComplex, imaginary part" (x.re x.im y.re y.im) (* (exp (- (* (log (sqrt (+ (* x.re x.re) (* x.im x.im)))) y.re) (* (atan2 x.im x.re) y.im))) (sin (+ (* (log (sqrt (+ (* x.re x.re) (* x.im x.im)))) y.im) (* (atan2 x.im x.re) y.re)))) #f #t TRUE binary64) #s(test "math.sqrt on complex, real part" (re im) (* 0.5 (sqrt (* 2.0 (+ (sqrt (+ (* re re) (* im im))) re)))) (if (< re 0) (* 0.5 (* (sqrt 2) (sqrt (/ (* im im) (- (sqrt (+ (* re re) (* im im))) re))))) (* 0.5 (sqrt (* 2.0 (+ (sqrt (+ (* re re) (* im im))) re))))) #t TRUE binary64) #s(test "math.sqrt on complex, imaginary part, im greater than 0 branch" (re im) (* 0.5 (sqrt (* 2.0 (- (sqrt (+ (* re re) (* im im))) re)))) #f #t TRUE binary64) #s(test "math.square on complex, real part" (re im) (- (* re re) (* im im)) #f #t TRUE binary64) #s(test "math.square on complex, imaginary part" (re im) (+ (* re im) (* im re)) #f #t TRUE binary64) #s(test "math.arg on complex" (re im) (atan2 im re) #f #t TRUE binary64) #s(test "normal distribution" (u1 u2) (+ (* (* (/ 1 6) (pow (* -2 (log u1)) 0.5)) (cos (* (* 2 PI) u2))) 0.5) #f #t (and (<= 0 u1 1) (<= 0 u2 1)) binary64) #s(test "math.cos on complex, real part" (re im) (* (* 0.5 (cos re)) (+ (exp (- im)) (exp im))) #f #t TRUE binary64) #s(test "math.cos on complex, imaginary part" (re im) (* (* 0.5 (sin re)) (- (exp (- im)) (exp im))) (if (< (fabs im) 1) (- (* (sin re) (+ (+ im (* (* (* 1/6 im) im) im)) (* (* (* (* (* 1/120 im) im) im) im) im)))) (* (* 0.5 (sin re)) (- (exp (- im)) (exp im)))) #t TRUE binary64) #s(test "math.sin on complex, real part" (re im) (* (* 0.5 (sin re)) (+ (exp (- 0 im)) (exp im))) #f #t TRUE binary64) #s(test "math.sin on complex, imaginary part" (re im) (* (* 0.5 (cos re)) (- (exp (- 0 im)) (exp im))) (if (< (fabs im) 1) (- (* (cos re) (+ (+ im (* (* (* 1/6 im) im) im)) (* (* (* (* (* 1/120 im) im) im) im) im)))) (* (* 0.5 (cos re)) (- (exp (- 0 im)) (exp im)))) #t TRUE binary64) #s(test "Octave 3.8, jcobi/1" (alpha beta) (/ (+ (/ (- beta alpha) (+ (+ alpha beta) 2.0)) 1.0) 2.0) #f #t (and (> alpha -1) (> beta -1)) binary64) #s(test "Octave 3.8, jcobi/2" (alpha beta i) (/ (+ (/ (/ (* (+ alpha beta) (- beta alpha)) (+ (+ alpha beta) (* 2 i))) (+ (+ (+ alpha beta) (* 2 i)) 2.0)) 1.0) 2.0) #f #t (and (> alpha -1) (> beta -1) (> i 0)) binary64) #s(test "Octave 3.8, jcobi/3" (alpha beta) (/ (/ (/ (+ (+ (+ alpha beta) (* beta alpha)) 1.0) (+ (+ alpha beta) (* 2 1))) (+ (+ alpha beta) (* 2 1))) (+ (+ (+ alpha beta) (* 2 1)) 1.0)) #f #t (and (> alpha -1) (> beta -1)) binary64) #s(test "Octave 3.8, jcobi/4" (alpha beta i) (/ (/ (* (* i (+ (+ alpha beta) i)) (+ (* beta alpha) (* i (+ (+ alpha beta) i)))) (* (+ (+ alpha beta) (* 2 i)) (+ (+ alpha beta) (* 2 i)))) (- (* (+ (+ alpha beta) (* 2 i)) (+ (+ alpha beta) (* 2 i))) 1.0)) #f #t (and (> alpha -1) (> beta -1) (> i 1)) binary64) #s(test "Octave 3.8, jcobi/4, as called" (i) (/ (/ (* (* i i) (* i i)) (* (* 2 i) (* 2 i))) (- (* (* 2 i) (* 2 i)) 1.0)) #f #t (and (> i 0)) binary64) #s(test "Octave 3.8, oct_fill_randg" (a rand) (* (- a (/ 1.0 3.0)) (+ 1 (* (/ 1 (sqrt (* 9 (- a (/ 1.0 3.0))))) rand))) #f #t TRUE binary64) #s(test "Exp of sum of logs" (a b) (exp (+ (log a) (log b))) (* a b) #t TRUE binary64) #s(test "Quotient of sum of exps" (a b) (/ (exp a) (+ (exp a) (exp b))) (/ 1 (+ 1 (exp (- b a)))) #t TRUE binary64) #s(test "Quotient of products" (a1 a2 b1 b2) (/ (* a1 a2) (* b1 b2)) (* (/ a1 b1) (/ a2 b2)) #t TRUE binary64) #s(test "a parameter of renormalized beta distribution" (m v) (* (- (/ (* m (- 1 m)) v) 1) m) #f #t (and (< 0 m) (< 0 v) (< v 0.25)) binary64) #s(test "b parameter of renormalized beta distribution" (m v) (* (- (/ (* m (- 1 m)) v) 1) (- 1 m)) #f #t (and (< 0 m) (< 0 v) (< v 0.25)) binary64) #s(test "Harley's example" (c_p c_n t s) (/ (* (pow (/ 1 (+ 1 (exp (- s)))) c_p) (pow (- 1 (/ 1 (+ 1 (exp (- s))))) c_n)) (* (pow (/ 1 (+ 1 (exp (- t)))) c_p) (pow (- 1 (/ 1 (+ 1 (exp (- t))))) c_n))) (* (pow (/ (+ 1 (exp (- t))) (+ 1 (exp (- s)))) c_p) (pow (/ (+ 1 (exp t)) (+ 1 (exp s))) c_n)) #t (and (< 0 c_p) (< 0 c_n)) binary64) #s(test "(- (/ x0 (- 1 x1)) x0)" (x0 x1) (- (/ x0 (- 1 x1)) x0) (/ (* x0 x1) (- 1 x1)) #t (or (and (== x0 1.855) (== x1 0.000209)) (and (== x0 2.985) (== x1 0.0186))) binary64) #s(test "Hyperbolic sine" (x) (/ (- (exp x) (exp (- x))) 2) #f #t TRUE binary64) #s(test "Hyperbolic tangent" (x) (/ (- (exp x) (exp (- x))) (+ (exp x) (exp (- x)))) #f #t TRUE binary64) #s(test "Hyperbolic secant" (x) (/ 2 (+ (exp x) (exp (- x)))) #f #t TRUE binary64) #s(test "Hyperbolic arcsine" (x) (log (+ x (sqrt (+ (* x x) 1)))) (if (< x 0) (log (/ -1 (- x (sqrt (+ (* x x) 1))))) (log (+ x (sqrt (+ (* x x) 1))))) #t TRUE binary64) #s(test "Hyperbolic arc-cosine" (x) (log (+ x (sqrt (- (* x x) 1)))) #f #t TRUE binary64) #s(test "Hyperbolic arc-(co)tangent" (x) (* (/ 1 2) (log (/ (+ 1 x) (- 1 x)))) #f #t TRUE binary64) #s(test "Hyperbolic arc-(co)secant" (x) (log (+ (/ 1 x) (/ (sqrt (- 1 (* x x))) x))) #f #t TRUE binary64) #s(test "Distance on a great circle" (R lambda1 lambda2 phi1 phi2) (* R (* 2 (atan2 (sqrt (+ (pow (sin (/ (- phi1 phi2) 2)) 2) (* (* (* (cos phi1) (cos phi2)) (sin (/ (- lambda1 lambda2) 2))) (sin (/ (- lambda1 lambda2) 2))))) (sqrt (- 1 (+ (pow (sin (/ (- phi1 phi2) 2)) 2) (* (* (* (cos phi1) (cos phi2)) (sin (/ (- lambda1 lambda2) 2))) (sin (/ (- lambda1 lambda2) 2))))))))) #f #t TRUE binary64) #s(test "Spherical law of cosines" (R lambda1 lambda2 phi1 phi2) (* (acos (+ (* (sin phi1) (sin phi2)) (* (* (cos phi1) (cos phi2)) (cos (- lambda1 lambda2))))) R) #f #t TRUE binary64) #s(test "Equirectangular approximation to distance on a great circle" (R lambda1 lambda2 phi1 phi2) (* R (sqrt (+ (* (* (- lambda1 lambda2) (cos (/ (+ phi1 phi2) 2))) (* (- lambda1 lambda2) (cos (/ (+ phi1 phi2) 2)))) (* (- phi1 phi2) (- phi1 phi2))))) #f #t TRUE binary64) #s(test "Bearing on a great circle" (lambda1 lambda2 phi1 phi2) (atan2 (* (sin (- lambda1 lambda2)) (cos phi2)) (- (* (cos phi1) (sin phi2)) (* (* (sin phi1) (cos phi2)) (cos (- lambda1 lambda2))))) #f #t TRUE binary64) #s(test "Midpoint on a great circle" (lambda1 lambda2 phi1 phi2) (+ lambda1 (atan2 (* (cos phi2) (sin (- lambda1 lambda2))) (+ (cos phi1) (* (cos phi2) (cos (- lambda1 lambda2)))))) #f #t TRUE binary64) #s(test "Destination given bearing on a great circle" (lambda1 phi1 phi2 delta theta) (+ lambda1 (atan2 (* (* (sin theta) (sin delta)) (cos phi1)) (- (cos delta) (* (sin phi1) (sin (asin (+ (* (sin phi1) (cos delta)) (* (* (cos phi1) (sin delta)) (cos theta))))))))) #f #t TRUE binary64) #s(test "Logistic regression 2" (x y) (- (log (+ 1 (exp x))) (* x y)) (if (<= x 0) (- (log (+ 1 (exp x))) (* x y)) (- (log (+ 1 (exp (- x)))) (* (- x) (- 1 y)))) #t TRUE binary64) #s(test "Logistic function from Lakshay Garg" (x y) (- (/ 2 (+ 1 (exp (* -2 x)))) 1) #f #t TRUE binary64) #s(test "Quadratic roots, full range" (a b c) (/ (+ (- b) (sqrt (- (* b b) (* (* 4 a) c)))) (* 2 a)) #f #t TRUE binary64) #s(test "Quadratic roots, narrow range" (a b c) (/ (+ (- b) (sqrt (- (* b b) (* (* 4 a) c)))) (* 2 a)) #f #t (and (< 1.0536712127723509e-08 a 94906265.62425156) (< 1.0536712127723509e-08 b 94906265.62425156) (< 1.0536712127723509e-08 c 94906265.62425156)) binary64) #s(test "Quadratic roots, medium range" (a b c) (/ (+ (- b) (sqrt (- (* b b) (* (* 4 a) c)))) (* 2 a)) #f #t (and (< 1.1102230246251565e-16 a 9007199254740992.0) (< 1.1102230246251565e-16 b 9007199254740992.0) (< 1.1102230246251565e-16 c 9007199254740992.0)) binary64) #s(test "Quadratic roots, wide range" (a b c) (/ (+ (- b) (sqrt (- (* b b) (* (* 4 a) c)))) (* 2 a)) #f #t (and (< 4.930380657631324e-32 a 2.028240960365167e+31) (< 4.930380657631324e-32 b 2.028240960365167e+31) (< 4.930380657631324e-32 c 2.028240960365167e+31)) binary64) #s(test "Cubic critical" (a b c) (/ (+ (- b) (sqrt (- (* b b) (* (* 3 a) c)))) (* 3 a)) #f #t TRUE binary64) #s(test "Cubic critical, narrow range" (a b c) (/ (+ (- b) (sqrt (- (* b b) (* (* 3 a) c)))) (* 3 a)) #f #t (and (< 1.0536712127723509e-08 a 94906265.62425156) (< 1.0536712127723509e-08 b 94906265.62425156) (< 1.0536712127723509e-08 c 94906265.62425156)) binary64) #s(test "Cubic critical, medium range" (a b c) (/ (+ (- b) (sqrt (- (* b b) (* (* 3 a) c)))) (* 3 a)) #f #t (and (< 1.1102230246251565e-16 a 9007199254740992.0) (< 1.1102230246251565e-16 b 9007199254740992.0) (< 1.1102230246251565e-16 c 9007199254740992.0)) binary64) #s(test "Cubic critical, wide range" (a b c) (/ (+ (- b) (sqrt (- (* b b) (* (* 3 a) c)))) (* 3 a)) #f #t (and (< 4.930380657631324e-32 a 2.028240960365167e+31) (< 4.930380657631324e-32 b 2.028240960365167e+31) (< 4.930380657631324e-32 c 2.028240960365167e+31)) binary64) #s(test "Asymptote A" (x) (- (/ 1 (+ x 1)) (/ 1 (- x 1))) #f #t TRUE binary64) #s(test "Asymptote B" (x) (+ (/ 1 (- x 1)) (/ x (+ x 1))) #f #t TRUE binary64) #s(test "Asymptote C" (x) (- (/ x (+ x 1)) (/ (+ x 1) (- x 1))) #f #t TRUE binary64) #s(test "Eccentricity of an ellipse" (a b) (sqrt (fabs (/ (- (* a a) (* b b)) (* a a)))) #f #t (<= 0 b a 1) binary64) #s(test "Trigonometry A" (e v) (/ (* e (sin v)) (+ 1 (* e (cos v)))) #f #t (<= 0 e 1) binary64) #s(test "Trigonometry B" (x) (/ (- 1 (* (tan x) (tan x))) (+ 1 (* (tan x) (tan x)))) #f #t TRUE binary64) #s(test "2-ancestry mixing, positive discriminant" (g h a) (+ (cbrt (* (/ 1 (* 2 a)) (+ (- g) (sqrt (- (* g g) (* h h)))))) (cbrt (* (/ 1 (* 2 a)) (- (- g) (sqrt (- (* g g) (* h h))))))) #f #t TRUE binary64) #s(test "2-ancestry mixing, zero discriminant" (g a) (cbrt (/ g (* 2 a))) #f #t TRUE binary64) #s(test "2-ancestry mixing, negative discriminant" (g h) (* 2 (cos (+ (/ (* 2 PI) 3) (/ (acos (/ (- g) h)) 3)))) #f #t TRUE binary64) #s(test "The quadratic formula (r1)" (a b c) (/ (+ (- b) (sqrt (- (* b b) (* (* 4 a) c)))) (* 2 a)) (if (< b 0) (/ (+ (- b) (sqrt (- (* b b) (* (* 4 a) c)))) (* 2 a)) (/ c (* a (/ (- (- b) (sqrt (- (* b b) (* (* 4 a) c)))) (* 2 a))))) #t TRUE binary64) #s(test "The quadratic formula (r2)" (a b c) (/ (- (- b) (sqrt (- (* b b) (* 4 (* a c))))) (* 2 a)) (if (< b 0) (/ c (* a (/ (+ (- b) (sqrt (- (* b b) (* 4 (* a c))))) (* 2 a)))) (/ (- (- b) (sqrt (- (* b b) (* 4 (* a c))))) (* 2 a))) #t TRUE binary64) #s(test "Difference of squares" (a b) (- (* a a) (* b b)) (* (+ a b) (- a b)) #t TRUE binary64) #s(test "Area of a triangle" (a b c) (sqrt (* (* (* (/ (+ (+ a b) c) 2) (- (/ (+ (+ a b) c) 2) a)) (- (/ (+ (+ a b) c) 2) b)) (- (/ (+ (+ a b) c) 2) c))) (/ (sqrt (* (* (* (+ a (+ b c)) (- c (- a b))) (+ c (- a b))) (+ a (- b c)))) 4) #t (and (< 0 a (+ b c)) (< 0 b (+ a c)) (< 0 c (+ a b))) binary64) #s(test "ln(1 + x)" (x) (log (+ 1 x)) (if (== (+ 1 x) 1) x (/ (* x (log (+ 1 x))) (- (+ 1 x) 1))) #t TRUE binary64) #s(test "Compound Interest" (i n) (* 100 (/ (- (pow (+ 1 (/ i n)) n) 1) (/ i n))) (* 100 (/ (- (exp (* n (if (== (+ 1 (/ i n)) 1) (/ i n) (/ (* (/ i n) (log (+ 1 (/ i n)))) (- (+ (/ i n) 1) 1))))) 1) (/ i n))) #t TRUE binary64) #s(test "x / (x^2 + 1)" (x) (/ x (+ (* x x) 1)) (/ 1 (+ x (/ 1 x))) #t TRUE binary64) #s(test "Complex division, real part" (a b c d) (/ (+ (* a c) (* b d)) (+ (* c c) (* d d))) (if (< (fabs d) (fabs c)) (/ (+ a (* b (/ d c))) (+ c (* d (/ d c)))) (/ (+ b (* a (/ c d))) (+ d (* c (/ c d))))) #t TRUE binary64) #s(test "Complex division, imag part" (a b c d) (/ (- (* b c) (* a d)) (+ (* c c) (* d d))) (if (< (fabs d) (fabs c)) (/ (- b (* a (/ d c))) (+ c (* d (/ d c)))) (/ (+ (- a) (* b (/ c d))) (+ d (* c (/ c d))))) #t TRUE binary64) #s(test "arccos" (x) (* 2 (atan (sqrt (/ (- 1 x) (+ 1 x))))) #f #t TRUE binary64) #s(test "fma_test1" (t) (+ (* (+ 1 (* t 2e-16)) (+ 1 (* t 2e-16))) (- -1 (* 2 (* t 2e-16)))) (fma (+ 1 (* t 2e-16)) (+ 1 (* t 2e-16)) (- -1 (* 2 (* t 2e-16)))) #t (<= 0.9 t 1.1) binary64) #s(test "fma_test2" (t) (- (* 1.7e+308 t) 1.7e+308) (fma 1.7e+308 t (- 1.7e+308)) #t (<= 1.9 t 2.1) binary64) #s(test "Kahan's Monster" (y) (if (== (* (- (fabs (- y (sqrt (+ (* y y) 1)))) (/ 1 (+ y (sqrt (+ (* y y) 1))))) (- (fabs (- y (sqrt (+ (* y y) 1)))) (/ 1 (+ y (sqrt (+ (* y y) 1)))))) 0) 1 (/ (- (exp (* (- (fabs (- y (sqrt (+ (* y y) 1)))) (/ 1 (+ y (sqrt (+ (* y y) 1))))) (- (fabs (- y (sqrt (+ (* y y) 1)))) (/ 1 (+ y (sqrt (+ (* y y) 1))))))) 1) (* (- (fabs (- y (sqrt (+ (* y y) 1)))) (/ 1 (+ y (sqrt (+ (* y y) 1))))) (- (fabs (- y (sqrt (+ (* y y) 1)))) (/ 1 (+ y (sqrt (+ (* y y) 1)))))))) #f #t (<= 1 y 9999) binary64) #s(test "Kahan's Unum-Targeted Monster" (y) (if (== (+ (* (- (fabs (- y (sqrt (+ (* y y) 1)))) (/ 1 (+ y (sqrt (+ (* y y) 1))))) (- (fabs (- y (sqrt (+ (* y y) 1)))) (/ 1 (+ y (sqrt (+ (* y y) 1)))))) (pow (pow 10 -300) (* 10000 (+ y 1)))) 0) 1 (/ (- (exp (+ (* (- (fabs (- y (sqrt (+ (* y y) 1)))) (/ 1 (+ y (sqrt (+ (* y y) 1))))) (- (fabs (- y (sqrt (+ (* y y) 1)))) (/ 1 (+ y (sqrt (+ (* y y) 1)))))) (pow (pow 10 -300) (* 10000 (+ y 1))))) 1) (+ (* (- (fabs (- y (sqrt (+ (* y y) 1)))) (/ 1 (+ y (sqrt (+ (* y y) 1))))) (- (fabs (- y (sqrt (+ (* y y) 1)))) (/ 1 (+ y (sqrt (+ (* y y) 1)))))) (pow (pow 10 -300) (* 10000 (+ y 1)))))) #f #t (<= 1 y 9999) binary64) #s(test "Kahan p9 Example" (x y) (/ (* (- x y) (+ x y)) (+ (* x x) (* y y))) (if (< 0.5 (fabs (/ x y)) 2) (/ (* (- x y) (+ x y)) (+ (* x x) (* y y))) (- 1 (/ 2 (+ 1 (* (/ x y) (/ x y)))))) #t (and (< 0 x 1) (< y 1)) binary64) #s(test "Kahan p13 Example 1" (t) (/ (+ 1 (* (/ (* 2 t) (+ 1 t)) (/ (* 2 t) (+ 1 t)))) (+ 2 (* (/ (* 2 t) (+ 1 t)) (/ (* 2 t) (+ 1 t))))) #f #t TRUE binary64) #s(test "Kahan p13 Example 2" (t) (/ (+ 1 (* (- 2 (/ (/ 2 t) (+ 1 (/ 1 t)))) (- 2 (/ (/ 2 t) (+ 1 (/ 1 t)))))) (+ 2 (* (- 2 (/ (/ 2 t) (+ 1 (/ 1 t)))) (- 2 (/ (/ 2 t) (+ 1 (/ 1 t))))))) #f #t TRUE binary64) #s(test "Kahan p13 Example 3" (t) (- 1 (/ 1 (+ 2 (* (- 2 (/ (/ 2 t) (+ 1 (/ 1 t)))) (- 2 (/ (/ 2 t) (+ 1 (/ 1 t)))))))) #f #t TRUE binary64) #s(test "NMSE Section 6.1 mentioned, A" (x eps) (/ (- (* (+ 1 (/ 1 eps)) (exp (- (* (- 1 eps) x)))) (* (- (/ 1 eps) 1) (exp (- (* (+ 1 eps) x))))) 2) #f #t TRUE binary64) #s(test "NMSE Section 6.1 mentioned, B" (a b) (* (* (/ PI 2) (/ 1 (- (* b b) (* a a)))) (- (/ 1 a) (/ 1 b))) #f #t TRUE binary64) #s(test "Radioactive exchange between two surfaces" (x y) (- (pow x 4) (pow y 4)) #f #t TRUE binary64) #s(test "Kahan's exp quotient" (x) (/ (- (exp x) 1) x) (if (and (< x 1) (> x -1)) (/ (- (exp x) 1) (log (exp x))) (/ (- (exp x) 1) x)) #t TRUE binary64) #s(test "simple fma test" (x y z) (- (fma x y z) (+ 1 (+ (* x y) z))) -1 #t TRUE binary64) #s(test "Rectangular parallelepiped of dimension abc" () (* 2 (+ (+ (* 1 (/ 1 9)) (* (/ 1 9) (/ 1 9))) (* (/ 1 9) 1))) (+ (+ (* (* (/ 1 9) 1) 2) (* 2 (* (/ 1 9) (/ 1 9)))) (* 2 (* 1 (/ 1 9)))) #t TRUE binary64) #s(test "Expression, p14" (a b c d) (* a (+ (+ b c) d)) (+ (* a b) (* a (+ c d))) #t (and (<= 56789 a 98765) (<= 0 b 1) (<= 0 c 0.0016773) (<= 0 d 0.0016773)) binary64) #s(test "Expression 1, p15" (a b c d e) (+ (+ (+ (+ e d) c) b) a) (+ (+ d (+ c (+ a b))) e) #t (<= 1 a 2 b 4 c 8 d 16 e 32) binary64) #s(test "Expression 2, p15" (x) (+ x (* x x)) (* (+ 1.0 x) x) #t (<= 0 x 2) binary64) #s(test "Expression 3, p15" (x) (+ (* x (* x x)) (* x x)) (* (* (+ 1.0 x) x) x) #t (<= 0 x 2) binary64) #s(test "Expression 4, p15" (a b) (* (+ a b) (+ a b)) (+ (+ (+ (* b a) (* b b)) (* b a)) (* a a)) #t (and (<= 5 a 10) (<= 0 b 0.001)) binary64) #s(test "Expression, p6" (a b c d) (* (+ a (+ b (+ c d))) 2) (+ (* (+ a b) 2) (* (+ c d) 2)) #t (and (<= -14 a -13) (<= -3 b -2) (<= 3 c 3.5) (<= 12.5 d 13.5)) binary64) #s(test "From Warwick Tucker's Validated Numerics" () (+ (+ (+ (* 333.75 (pow 33096 6)) (* (* 77617 77617) (+ (+ (+ (* (* 11 (* 77617 77617)) (* 33096 33096)) (- (pow 33096 6))) (* -121 (pow 33096 4))) -2))) (* 5.5 (pow 33096 8))) (/ 77617 (* 2 33096))) #f #t TRUE binary64) #s(test "Rosa's DopplerBench" (u v t1) (/ (* (- t1) v) (* (+ t1 u) (+ t1 u))) #f #t TRUE binary64) #s(test "Rosa's Benchmark" (x) (- (* 0.954929658551372 x) (* 0.12900613773279798 (* (* x x) x))) #f #t TRUE binary64) #s(test "Rosa's FloatVsDoubleBenchmark" (x1 x2) (+ x1 (+ (+ (+ (+ (* (+ (* (* (* 2 x1) (/ (- (+ (* (* 3 x1) x1) (* 2 x2)) x1) (+ (* x1 x1) 1))) (- (/ (- (+ (* (* 3 x1) x1) (* 2 x2)) x1) (+ (* x1 x1) 1)) 3)) (* (* x1 x1) (- (* 4 (/ (- (+ (* (* 3 x1) x1) (* 2 x2)) x1) (+ (* x1 x1) 1))) 6))) (+ (* x1 x1) 1)) (* (* (* 3 x1) x1) (/ (- (+ (* (* 3 x1) x1) (* 2 x2)) x1) (+ (* x1 x1) 1)))) (* (* x1 x1) x1)) x1) (* 3 (/ (- (- (* (* 3 x1) x1) (* 2 x2)) x1) (+ (* x1 x1) 1))))) #f #t TRUE binary64) #s(test "Rosa's TurbineBenchmark" (v w r) (- (- (+ 3 (/ 2 (* r r))) (/ (* (* 0.125 (- 3 (* 2 v))) (* (* (* w w) r) r)) (- 1 v))) 4.5) #f #t TRUE binary64) #s(test "Maksimov and Kolovsky, Equation (3)" (J K U) (* (* (* -2 J) (cos (/ K 2))) (sqrt (+ 1 (pow (/ U (* (* 2 J) (cos (/ K 2)))) 2)))) #f #t TRUE binary64) #s(test "Maksimov and Kolovsky, Equation (4)" (J l K U) (+ (* (* J (- (exp l) (exp (- l)))) (cos (/ K 2))) U) #f #t TRUE binary64) #s(test "Maksimov and Kolovsky, Equation (32)" (K m n M l) (* (cos (- (/ (* K (+ m n)) 2) M)) (exp (- (- (pow (- (/ (+ m n) 2) M) 2)) (- l (fabs (- m n)))))) #f #t TRUE binary64) #s(test "Bulmash initializePoisson" (NdChar Ec Vef EDonor mu KbT NaChar Ev EAccept) (+ (/ NdChar (+ 1 (exp (/ (- (- (- (- Ec Vef) EDonor) mu)) KbT)))) (/ NaChar (+ 1 (exp (/ (+ (+ (+ Ev Vef) EAccept) (- mu)) KbT))))) #f #t TRUE binary64) #s(test "Migdal et al, Equation (51)" (k n) (* (/ 1 (sqrt k)) (pow (* (* 2 PI) n) (/ (- 1 k) 2))) #f #t TRUE binary64) #s(test "Migdal et al, Equation (64)" (a1 a2 th) (+ (* (/ (cos th) (sqrt 2)) (* a1 a1)) (* (/ (cos th) (sqrt 2)) (* a2 a2))) #f #t TRUE binary64) #s(test "Falkner and Boettcher, Equation (20:1,3)" (v t) (/ (- 1 (* 5 (* v v))) (* (* (* PI t) (sqrt (* 2 (- 1 (* 3 (* v v)))))) (- 1 (* v v)))) #f #t TRUE binary64) #s(test "Falkner and Boettcher, Equation (22+)" (v) (/ 4 (* (* (* 3 PI) (- 1 (* v v))) (sqrt (- 2 (* 6 (* v v)))))) #f #t TRUE binary64) #s(test "Falkner and Boettcher, Appendix A" (a k m) (/ (* a (pow k m)) (+ (+ 1 (* 10 k)) (* k k))) #f #t TRUE binary64) #s(test "Falkner and Boettcher, Appendix B, 1" (v) (acos (/ (- 1 (* 5 (* v v))) (- (* v v) 1))) #f #t TRUE binary64) #s(test "Falkner and Boettcher, Appendix B, 2" (v) (* (* (/ (sqrt 2) 4) (sqrt (- 1 (* 3 (* v v))))) (- 1 (* v v))) #f #t TRUE binary64) #s(test "Given's Rotation SVD example" (p x) (sqrt (* 0.5 (+ 1 (/ x (sqrt (+ (* (* 4 p) p) (* x x))))))) (sqrt (+ 1/2 (/ (copysign 1/2 x) (hypot 1 (/ (* 2 p) x))))) #t (< 1e-150 (fabs x) 1e+150) binary64) #s(test "Given's Rotation SVD example, simplified" (x) (- 1 (sqrt (* 1/2 (+ 1 (/ 1 (hypot 1 x)))))) #f #t TRUE binary64) #s(test "Toniolo and Linder, Equation (2)" (t l Om Omc) (asin (sqrt (/ (- 1 (pow (/ Om Omc) 2)) (+ 1 (* 2 (pow (/ t l) 2)))))) #f #t TRUE binary64) #s(test "Toniolo and Linder, Equation (3a)" (l Om kx ky) (sqrt (* (/ 1 2) (+ 1 (/ 1 (sqrt (+ 1 (* (pow (/ (* 2 l) Om) 2) (+ (pow (sin kx) 2) (pow (sin ky) 2))))))))) #f #t TRUE binary64) #s(test "Toniolo and Linder, Equation (3b), real" (kx ky th) (* (/ (sin ky) (sqrt (+ (pow (sin kx) 2) (pow (sin ky) 2)))) (sin th)) #f #t TRUE binary64) #s(test "Toniolo and Linder, Equation (7)" (x l t) (/ (* (sqrt 2) t) (sqrt (- (* (/ (+ x 1) (- x 1)) (+ (* l l) (* 2 (* t t)))) (* l l)))) #f #t TRUE binary64) #s(test "Toniolo and Linder, Equation (10+)" (t l k) (/ 2 (* (* (* (/ (pow t 3) (* l l)) (sin k)) (tan k)) (+ (+ 1 (pow (/ k t) 2)) 1))) #f #t TRUE binary64) #s(test "Toniolo and Linder, Equation (10-)" (t l k) (/ 2 (* (* (* (/ (pow t 3) (* l l)) (sin k)) (tan k)) (- (+ 1 (pow (/ k t) 2)) 1))) #f #t TRUE binary64) #s(test "Toniolo and Linder, Equation (13)" (n U t l Om U*) (sqrt (* (* (* 2 n) U) (- (- t (* 2 (/ (* l l) Om))) (* (* n (pow (/ l Om) 2)) (- U U*))))) #f #t TRUE binary64) #s(test "VandenBroeck and Keller, Equation (6)" (F l) (- (* PI l) (* (/ 1 (* F F)) (tan (* PI l)))) #f #t TRUE binary64) #s(test "VandenBroeck and Keller, Equation (20)" (f) (- (* (/ 1 (/ PI 4)) (log (/ (+ (exp (* (/ PI 4) f)) (exp (- (* (/ PI 4) f)))) (- (exp (* (/ PI 4) f)) (exp (- (* (/ PI 4) f)))))))) #f #t TRUE binary64) #s(test "VandenBroeck and Keller, Equation (23)" (F B x) (+ (- (* x (/ 1 (tan B)))) (* (/ F (sin B)) (pow (+ (+ (* F F) 2) (* 2 x)) (- (/ 1 2))))) #f #t TRUE binary64) #s(test "VandenBroeck and Keller, Equation (24)" (B x) (+ (- (* x (/ 1 (tan B)))) (/ 1 (sin B))) #f #t TRUE binary64) #s(test "Henrywood and Agarwal, Equation (3)" (c0 A V l) (* c0 (sqrt (/ A (* V l)))) #f #t TRUE binary64) #s(test "Henrywood and Agarwal, Equation (9a)" (w0 M D h l d) (* w0 (sqrt (- 1 (* (pow (/ (* M D) (* 2 d)) 2) (/ h l))))) #f #t TRUE binary64) #s(test "Henrywood and Agarwal, Equation (12)" (d h l M D) (* (* (pow (/ d h) (/ 1 2)) (pow (/ d l) (/ 1 2))) (- 1 (* (* (/ 1 2) (pow (/ (* M D) (* 2 d)) 2)) (/ h l)))) #f #t TRUE binary64) #s(test "Henrywood and Agarwal, Equation (13)" (c0 w h D d M) (* (/ c0 (* 2 w)) (+ (/ (* c0 (* d d)) (* (* w h) (* D D))) (sqrt (- (* (/ (* c0 (* d d)) (* (* w h) (* D D))) (/ (* c0 (* d d)) (* (* w h) (* D D)))) (* M M))))) #f #t TRUE binary64) #s(test "Bouland and Aaronson, Equation (24)" (a b) (- (+ (pow (+ (* a a) (* b b)) 2) (* 4 (+ (* (* a a) (- 1 a)) (* (* b b) (+ 3 a))))) 1) #f #t TRUE binary64) #s(test "Bouland and Aaronson, Equation (25)" (a b) (- (+ (pow (+ (* a a) (* b b)) 2) (* 4 (+ (* (* a a) (+ 1 a)) (* (* b b) (- 1 (* 3 a)))))) 1) #f #t TRUE binary64) #s(test "Bouland and Aaronson, Equation (26)" (a b) (- (+ (pow (+ (* a a) (* b b)) 2) (* 4 (* b b))) 1) #f #t TRUE binary64) #s(test "Area of a triangle" (a b c) (sqrt.p16 (*.p16 (*.p16 (*.p16 (/.p16 (+.p16 (+.p16 a b) c) (real->posit16 2)) (-.p16 (/.p16 (+.p16 (+.p16 a b) c) (real->posit16 2)) a)) (-.p16 (/.p16 (+.p16 (+.p16 a b) c) (real->posit16 2)) b)) (-.p16 (/.p16 (+.p16 (+.p16 a b) c) (real->posit16 2)) c))) #f #t (and (<.p16 (real->posit16 0) a) (<.p16 (real->posit16 0) b) (<.p16 (real->posit16 0) c)) posit16) #s(test "(/ (- x lo) (- hi lo))" (lo hi x) (/.p16 (-.p16 x lo) (-.p16 hi lo)) #f #t (and (<.p16 lo (real->posit16 -1e+308)) (>.p16 hi (real->posit16 1e+308))) posit16) #s(test "quadp (p42, positive)" (a b c) (/.p16 (+.p16 (neg.p16 b) (sqrt.p16 (-.p16 (*.p16 b b) (*.p16 (real->posit16 4) (*.p16 a c))))) (*.p16 (real->posit16 2) a)) #f #t TRUE posit16) #s(test "quadm (p42, negative)" (a b c) (/.p16 (-.p16 (neg.p16 b) (sqrt.p16 (-.p16 (*.p16 b b) (*.p16 (real->posit16 4) (*.p16 a c))))) (*.p16 (real->posit16 2) a)) #f #t TRUE posit16) #s(test "quad2m (problem 3.2.1, negative)" (a b_2 c) (/.p16 (-.p16 (neg.p16 b_2) (sqrt.p16 (-.p16 (*.p16 b_2 b_2) (*.p16 a c)))) a) #f #t TRUE posit16) #s(test "quad2p (problem 3.2.1, positive)" (a b_2 c) (/.p16 (+.p16 (neg.p16 b_2) (sqrt.p16 (-.p16 (*.p16 b_2 b_2) (*.p16 a c)))) a) #f #t TRUE posit16) #s(test "2sqrt (example 3.1)" (x) (-.p16 (sqrt.p16 (+.p16 x (real->posit16 1))) (sqrt.p16 x)) #f #t TRUE posit16) #s(test "2isqrt (example 3.6)" (x) (-.p16 (/.p16 (real->posit16 1) (sqrt.p16 x)) (/.p16 (real->posit16 1) (sqrt.p16 (+.p16 x (real->posit16 1))))) #f #t TRUE posit16) #s(test "2frac (problem 3.3.1)" (x) (-.p16 (/.p16 (real->posit16 1) (+.p16 x (real->posit16 1))) (/.p16 (real->posit16 1) x)) #f #t TRUE posit16) #s(test "3frac (problem 3.3.3)" (x) (+.p16 (-.p16 (/.p16 (real->posit16 1) (+.p16 x (real->posit16 1))) (/.p16 (real->posit16 2) x)) (/.p16 (real->posit16 1) (-.p16 x (real->posit16 1)))) #f #t TRUE posit16) #s(test "math.abs on complex" (re im) (sqrt.p16 (+.p16 (*.p16 re re) (*.p16 im im))) #f #t TRUE posit16) #s(test "math.cube on complex, real part" (x.re x.im) (-.p16 (*.p16 (-.p16 (*.p16 x.re x.re) (*.p16 x.im x.im)) x.re) (*.p16 (+.p16 (*.p16 x.re x.im) (*.p16 x.im x.re)) x.im)) #f #t TRUE posit16) #s(test "math.cube on complex, imaginary part" (x.re x.im) (+.p16 (*.p16 (-.p16 (*.p16 x.re x.re) (*.p16 x.im x.im)) x.im) (*.p16 (+.p16 (*.p16 x.re x.im) (*.p16 x.im x.re)) x.re)) #f #t TRUE posit16) #s(test "_divideComplex, real part" (x.re x.im y.re y.im) (/.p16 (+.p16 (*.p16 x.re y.re) (*.p16 x.im y.im)) (+.p16 (*.p16 y.re y.re) (*.p16 y.im y.im))) #f #t TRUE posit16) #s(test "_divideComplex, imaginary part" (x.re x.im y.re y.im) (/.p16 (-.p16 (*.p16 x.im y.re) (*.p16 x.re y.im)) (+.p16 (*.p16 y.re y.re) (*.p16 y.im y.im))) #f #t TRUE posit16) #s(test "_multiplyComplex, real part" (x.re x.im y.re y.im) (-.p16 (*.p16 x.re y.re) (*.p16 x.im y.im)) #f #t TRUE posit16) #s(test "_multiplyComplex, imaginary part" (x.re x.im y.re y.im) (+.p16 (*.p16 x.re y.im) (*.p16 x.im y.re)) #f #t TRUE posit16) #s(test "math.sqrt on complex, real part" (re im) (*.p16 (real->posit16 0.5) (sqrt.p16 (*.p16 (real->posit16 2.0) (+.p16 (sqrt.p16 (+.p16 (*.p16 re re) (*.p16 im im))) re)))) #f #t TRUE posit16) #s(test "math.sqrt on complex, imaginary part, im greater than 0 branch" (re im) (*.p16 (real->posit16 0.5) (sqrt.p16 (*.p16 (real->posit16 2.0) (-.p16 (sqrt.p16 (+.p16 (*.p16 re re) (*.p16 im im))) re)))) #f #t TRUE posit16) #s(test "math.square on complex, real part" (re im) (-.p16 (*.p16 re re) (*.p16 im im)) #f #t TRUE posit16) #s(test "math.square on complex, imaginary part" (re im) (+.p16 (*.p16 re im) (*.p16 im re)) #f #t TRUE posit16) #s(test "Octave 3.8, jcobi/1" (alpha beta) (/.p16 (+.p16 (/.p16 (-.p16 beta alpha) (+.p16 (+.p16 alpha beta) (real->posit16 2.0))) (real->posit16 1.0)) (real->posit16 2.0)) #f #t (and (>.p16 alpha (real->posit16 -1)) (>.p16 beta (real->posit16 -1))) posit16) #s(test "Octave 3.8, jcobi/2" (alpha beta i) (/.p16 (+.p16 (/.p16 (/.p16 (*.p16 (+.p16 alpha beta) (-.p16 beta alpha)) (+.p16 (+.p16 alpha beta) (*.p16 (real->posit16 2) i))) (+.p16 (+.p16 (+.p16 alpha beta) (*.p16 (real->posit16 2) i)) (real->posit16 2.0))) (real->posit16 1.0)) (real->posit16 2.0)) #f #t (and (>.p16 alpha (real->posit16 -1)) (>.p16 beta (real->posit16 -1)) (>.p16 i (real->posit16 0))) posit16) #s(test "Octave 3.8, jcobi/3" (alpha beta) (/.p16 (/.p16 (/.p16 (+.p16 (+.p16 (+.p16 alpha beta) (*.p16 beta alpha)) (real->posit16 1.0)) (+.p16 (+.p16 alpha beta) (*.p16 (real->posit16 2) (real->posit16 1)))) (+.p16 (+.p16 alpha beta) (*.p16 (real->posit16 2) (real->posit16 1)))) (+.p16 (+.p16 (+.p16 alpha beta) (*.p16 (real->posit16 2) (real->posit16 1))) (real->posit16 1.0))) #f #t (and (>.p16 alpha (real->posit16 -1)) (>.p16 beta (real->posit16 -1))) posit16) #s(test "Octave 3.8, jcobi/4" (alpha beta i) (/.p16 (/.p16 (*.p16 (*.p16 i (+.p16 (+.p16 alpha beta) i)) (+.p16 (*.p16 beta alpha) (*.p16 i (+.p16 (+.p16 alpha beta) i)))) (*.p16 (+.p16 (+.p16 alpha beta) (*.p16 (real->posit16 2) i)) (+.p16 (+.p16 alpha beta) (*.p16 (real->posit16 2) i)))) (-.p16 (*.p16 (+.p16 (+.p16 alpha beta) (*.p16 (real->posit16 2) i)) (+.p16 (+.p16 alpha beta) (*.p16 (real->posit16 2) i))) (real->posit16 1.0))) #f #t (and (>.p16 alpha (real->posit16 -1)) (>.p16 beta (real->posit16 -1)) (>.p16 i (real->posit16 1))) posit16) #s(test "Octave 3.8, jcobi/4, as called" (i) (/.p16 (/.p16 (*.p16 (*.p16 i i) (*.p16 i i)) (*.p16 (*.p16 (real->posit16 2) i) (*.p16 (real->posit16 2) i))) (-.p16 (*.p16 (*.p16 (real->posit16 2) i) (*.p16 (real->posit16 2) i)) (real->posit16 1.0))) #f #t (and (>.p16 i (real->posit16 0))) posit16) #s(test "Octave 3.8, oct_fill_randg" (a rand) (*.p16 (-.p16 a (/.p16 (real->posit16 1.0) (real->posit16 3.0))) (+.p16 (real->posit16 1) (*.p16 (/.p16 (real->posit16 1) (sqrt.p16 (*.p16 (real->posit16 9) (-.p16 a (/.p16 (real->posit16 1.0) (real->posit16 3.0)))))) rand))) #f #t TRUE posit16) #s(test "FastMath dist" (d1 d2 d3) (+.p16 (*.p16 d1 d2) (*.p16 d1 d3)) #f #t TRUE posit16) #s(test "FastMath test1" (d) (+.p16 (*.p16 d (real->posit16 10)) (*.p16 d (real->posit16 20))) #f #t TRUE posit16) #s(test "FastMath test2" (d1 d2) (+.p16 (+.p16 (*.p16 d1 (real->posit16 10)) (*.p16 d1 d2)) (*.p16 d1 (real->posit16 20))) #f #t TRUE posit16) #s(test "FastMath dist3" (d1 d2 d3) (+.p16 (+.p16 (*.p16 d1 d2) (*.p16 (+.p16 d3 (real->posit16 5)) d1)) (*.p16 d1 (real->posit16 32))) #f #t TRUE posit16) #s(test "FastMath dist4" (d1 d2 d3 d4) (-.p16 (+.p16 (-.p16 (*.p16 d1 d2) (*.p16 d1 d3)) (*.p16 d4 d1)) (*.p16 d1 d1)) #f #t TRUE posit16) #s(test "FastMath test3" (d1 d2 d3) (+.p16 (+.p16 (*.p16 d1 (real->posit16 3)) (*.p16 d1 d2)) (*.p16 d1 d3)) #f #t TRUE posit16) #s(test "FastMath repmul" (d1) (*.p16 (*.p16 (*.p16 d1 d1) d1) d1) #f #t TRUE posit16) #s(test "Jmat.Real.dawson" (x) (*.p16 (/.p16 (+.p16 (+.p16 (+.p16 (+.p16 (+.p16 (real->posit16 1) (*.p16 (real->posit16 0.1049934947) (*.p16 x x))) (*.p16 (real->posit16 0.0424060604) (*.p16 (*.p16 x x) (*.p16 x x)))) (*.p16 (real->posit16 0.0072644182) (*.p16 (*.p16 (*.p16 x x) (*.p16 x x)) (*.p16 x x)))) (*.p16 (real->posit16 0.0005064034) (*.p16 (*.p16 (*.p16 (*.p16 x x) (*.p16 x x)) (*.p16 x x)) (*.p16 x x)))) (*.p16 (real->posit16 0.0001789971) (*.p16 (*.p16 (*.p16 (*.p16 (*.p16 x x) (*.p16 x x)) (*.p16 x x)) (*.p16 x x)) (*.p16 x x)))) (+.p16 (+.p16 (+.p16 (+.p16 (+.p16 (+.p16 (real->posit16 1) (*.p16 (real->posit16 0.7715471019) (*.p16 x x))) (*.p16 (real->posit16 0.2909738639) (*.p16 (*.p16 x x) (*.p16 x x)))) (*.p16 (real->posit16 0.0694555761) (*.p16 (*.p16 (*.p16 x x) (*.p16 x x)) (*.p16 x x)))) (*.p16 (real->posit16 0.0140005442) (*.p16 (*.p16 (*.p16 (*.p16 x x) (*.p16 x x)) (*.p16 x x)) (*.p16 x x)))) (*.p16 (real->posit16 0.0008327945) (*.p16 (*.p16 (*.p16 (*.p16 (*.p16 x x) (*.p16 x x)) (*.p16 x x)) (*.p16 x x)) (*.p16 x x)))) (*.p16 (*.p16 (real->posit16 2) (real->posit16 0.0001789971)) (*.p16 (*.p16 (*.p16 (*.p16 (*.p16 (*.p16 x x) (*.p16 x x)) (*.p16 x x)) (*.p16 x x)) (*.p16 x x)) (*.p16 x x))))) x) #f #t TRUE posit16) #s(test "Graphics.Rendering.Chart.Backend.Diagrams:calcFontMetrics from Chart-diagrams-1.5.1" (x y z t) (* x (/ (* (/ y z) t) t)) #f #t TRUE binary64) #s(test "(+ x (- (tan (+ y z)) (tan a)))" (x y z a) (+ x (- (tan (+ y z)) (tan a))) #f #t (and (or (== x 0) (<= 0.5884142 x 505.5909)) (or (<= -1.796658e+308 y -9.425585e-310) (<= 1.284938e-309 y 1.751224e+308)) (or (<= -1.776707e+308 z -8.599796e-310) (<= 3.293145e-311 z 1.725154e+308)) (or (<= -1.796658e+308 a -9.425585e-310) (<= 1.284938e-309 a 1.751224e+308))) binary64) #s(test "cos(2*x)/(cos^2(x)*sin^2(x))" (x cos sin) (/ (cos (* 2 x)) (* (pow cos 2) (* (* x (pow sin 2)) x))) #f #t TRUE binary64) #s(test "x" (x) x #f #t (or (== x 0) (== x 10)) binary64) #s(test "r*sin(b)/cos(a+b), A" (r a b) (/ (* r (sin b)) (cos (+ a b))) #f #t TRUE binary64) #s(test "r*sin(b)/cos(a+b), B" (r a b) (* r (/ (sin b) (cos (+ a b)))) #f #t TRUE binary64) #s(test "Fuzzer 001" (a) (/ a (- (acos a))) #f #t TRUE binary64) #s(test "Fuzzer 002" (a) (pow (atan (fmod a (asin a))) (* a a)) #f #t TRUE binary64) #s(test "Numeric.SpecFunctions:logGammaL from math-functions-0.1.5.2" (x y z t a) (+ (- (+ (log (+ x y)) (log z)) t) (* (- a 0.5) (log t))) #f #t TRUE binary64) #s(test "Numeric.SpecFunctions:logGamma from math-functions-0.1.5.2" (x y z t a b c i) (/ (+ (* (+ (* (+ (* (+ (* x y) z) y) 27464.7644705) y) 230661.510616) y) t) (+ (* (+ (* (+ (* (+ y a) y) b) y) c) y) i)) #f #t TRUE binary64) #s(test "Linear.V4:$cdot from linear-1.19.1.3" (x y z t a b c i) (+ (+ (+ (* x y) (* z t)) (* a b)) (* c i)) #f #t TRUE binary64) #s(test "Linear.Matrix:det44 from linear-1.19.1.3" (x y z t a b c i j k y0 y1 y2 y3 y4 y5) (+ (- (+ (+ (- (* (- (* x y) (* z t)) (- (* a b) (* c i))) (* (- (* x j) (* z k)) (- (* y0 b) (* y1 i)))) (* (- (* x y2) (* z y3)) (- (* y0 c) (* y1 a)))) (* (- (* t j) (* y k)) (- (* y4 b) (* y5 i)))) (* (- (* t y2) (* y y3)) (- (* y4 c) (* y5 a)))) (* (- (* k y2) (* j y3)) (- (* y4 y1) (* y5 y0)))) #f #t TRUE binary64) #s(test "Linear.Matrix:det33 from linear-1.19.1.3" (x y z t a b c i j) (+ (- (* x (- (* y z) (* t a))) (* b (- (* c z) (* i a)))) (* j (- (* c t) (* i y)))) #f #t TRUE binary64) #s(test "Hakyll.Web.Tags:renderTagCloud from hakyll-4.7.2.3" (x y z t a) (+ x (* (/ (- y z) (- (+ t 1.0) z)) (- a x))) #f #t TRUE binary64) #s(test "Diagrams.Solve.Polynomial:cubForm  from diagrams-solve-0.1" (x y z t a b c i j k) (- (- (+ (- (* (* (* (* x 18.0) y) z) t) (* (* a 4.0) t)) (* b c)) (* (* x 4.0) i)) (* (* j 27.0) k)) #f #t TRUE binary64) #s(test "Bouland and Aaronson, Equation (25)" (a b) (- (+ (pow (+ (* a a) (* b b)) 2) (* 4 (+ (* (* a a) (+ 1 a)) (* (* b b) (- 1 (* 3 a)))))) 1) #f #t TRUE binary64) #s(test "The quadratic formula (r1)" (a b c) (/ (+ (- b) (sqrt (- (* b b) (* (* 4 a) c)))) (* 2 a)) (if (< b 0) (/ (+ (- b) (sqrt (- (* b b) (* (* 4 a) c)))) (* 2 a)) (/ c (* a (/ (- (- b) (sqrt (- (* b b) (* (* 4 a) c)))) (* 2 a))))) #t TRUE binary64) #s(test "NMSE problem 3.2.1" (a b_2 c) (/ (- (- b_2) (sqrt (- (* b_2 b_2) (* a c)))) a) #f #t TRUE binary64) #s(test "Numeric.SpecFunctions:invIncompleteBetaWorker from math-functions-0.1.5.2" (x y z t a b c) (/ x (+ x (* y (exp (* 2.0 (- (/ (* z (sqrt (+ t a))) t) (* (- b c) (- (+ a (/ 5.0 6.0)) (/ 2.0 (* t 3.0)))))))))) #f #t TRUE binary64) #s(test "Numeric.SpecFunctions:incompleteBetaWorker from math-functions-0.1.5.2" (x y z t a b) (/ (* x (exp (- (+ (* y (log z)) (* (- t 1.0) (log a))) b))) y) #f #t TRUE binary64) #s(test "fabs fraction 1" (x y z) (fabs (- (/ (+ x 4) y) (* (/ x y) z))) #f #t TRUE binary64) #s(test "fabs fraction 2" (a b) (/ (fabs (- a b)) 2) #f #t TRUE binary64) #s(test "subtraction fraction" (f n) (/ (- (+ f n)) (- f n)) #f #t TRUE binary64) #s(test "exp neg sub" (x) (exp (- (- 1 (* x x)))) #f #t TRUE binary64) #s(test "sqrt times" (x) (* (sqrt (- x 1)) (sqrt x)) #f #t TRUE binary64) #s(test "neg log" (x) (- (log (- (/ 1 x) 1))) #f #t TRUE binary64) #s(test "VandenBroeck and Keller, Equation (24)" (B x) (+ (- (* x (/ 1 (tan B)))) (/ 1 (sin B))) #f #t TRUE binary64) #s(test "sqrt sqr" (x) (- (/ x x) (* (/ 1 x) (sqrt (* x x)))) (if (< x 0) 2 0) #t TRUE binary64) #s(test "jeff quadratic root 1" (a b c) (if (>= b 0) (/ (- (- b) (sqrt (- (* b b) (* (* 4 a) c)))) (* 2 a)) (/ (* 2 c) (+ (- b) (sqrt (- (* b b) (* (* 4 a) c)))))) #f #t TRUE binary64) #s(test "jeff quadratic root 2" (a b c) (if (>= b 0) (/ (* 2 c) (- (- b) (sqrt (- (* b b) (* (* 4 a) c))))) (/ (+ (- b) (sqrt (- (* b b) (* (* 4 a) c)))) (* 2 a))) #f #t TRUE binary64) #s(test "Cancel like terms" (x) (- (+ 1 x) x) #f #t TRUE binary64) #s(test "Expanding a square" (x) (- (* (+ x 1) (+ x 1)) 1) #f #t TRUE binary64) #s(test "Commute and associate" (x y z) (- (+ (+ x y) z) (+ x (+ y z))) #f #t TRUE binary64))
"Here"
Running 1 brass eval workers on 541 tests (seed: 346025831)
